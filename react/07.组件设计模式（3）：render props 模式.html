<!DOCTYPE html>
<html>
<head>
<title>组件设计模式（3）：render props 模式.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89%EF%BC%9Arender-props-%E6%A8%A1%E5%BC%8F">组件设计模式（3）：render props 模式</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>在上一小节中，我们介绍了高阶组件，高阶组件并不是 React 中唯一的重用组件逻辑的方式，在这一小节中，我们会介绍另一种方式 render props。</p>
<h2 id="render-props">render props</h2>
<p>所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。</p>
<p>一个最简单的 render props 组件 <code>RenderAll</code>，代码如下：</p>
<pre class="hljs"><code><div>const RenderAll = (props) =&gt; {
  return(
     &lt;React.Fragment&gt;
     	{props.children(props)}
     &lt;/React.Fragment&gt;
  );
};


</div></code></pre>
<p>这个 <code>RenderAll</code> 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做。</p>
<p>使用 RenderAll 的代码如下：</p>
<pre class="hljs"><code><div>      &lt;RenderAll&gt;
        {() =&gt; &lt;h1&gt;hello world&lt;/h1&gt;}
      &lt;/RenderAll&gt;

</div></code></pre>
<p>可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 <code>&lt;h1&gt;hello world&lt;/h1&gt;</code>，这就是上面使用 RenderAll 渲染出来的结果。</p>
<p>当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。</p>
<h2 id="%E4%BC%A0%E9%80%92-props">传递 props</h2>
<p>和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props。</p>
<p>下面是实现 render props 的 <code>Login</code> 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。</p>
<pre class="hljs"><code><div>const Login = (props) =&gt; {
  const userName = getUserName();

  if (userName) {
    const allProps = {userName, ...props};
    return (
      &lt;React.Fragment&gt;
        {props.children(allProps)}
      &lt;/React.Fragment&gt;
    );
  } else {
    return null;
  }
};


</div></code></pre>
<p>当用户处于登录状态，<code>getUserName</code> 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 <code>props.children</code> 返回的结果。</p>
<p>当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 <code>userName</code> 作为增加的 props 传递给下去，这样就是 Login 的增强功能。</p>
<p>一个使用上面 Login 的 JSX 代码示例如下：</p>
<pre class="hljs"><code><div>  &lt;Login&gt;
    {({userName}) =&gt; &lt;h1&gt;Hello {userName}&lt;/h1&gt;}
  &lt;/Login&gt;

</div></code></pre>
<p>对于名为“程墨Morgan”的用户登录，上面的 JSX 会产生 <code>&lt;h1&gt;Hello 程墨Morgan&lt;/h1&gt;</code>。</p>
<h2 id="%E4%B8%8D%E5%B1%80%E9%99%90%E4%BA%8E-children">不局限于 children</h2>
<p>在上面的例子中，作为 render 方法的 props 就是 <code>children</code>，在我写的<a href="https://zhuanlan.zhihu.com/p/26648239">《深入浅出React和Redux》</a>中，将这种模式称为“以函数为子组件（function as child）”的模式，这可以算是 render props 的一种具体形式，也就利用 <code>children</code> 这个 props 来作为函数传递。</p>
<p>实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。</p>
<p>我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 <code>Auth</code>，对应代码如下：</p>
<pre class="hljs"><code><div>const Auth= (props) =&gt; {
  const userName = getUserName();

  if (userName) {
    const allProps = {userName, ...props};
    return (
      &lt;React.Fragment&gt;
        {props.login(allProps)}
      &lt;/React.Fragment&gt;
    );
  } else {
    &lt;React.Fragment&gt;
      {props.nologin(props)}
    &lt;/React.Fragment&gt;
  }
};

</div></code></pre>
<p>使用 Auth 的话，可以分别通过 <code>login</code> 和 <code>nologin</code> 两个 props 来指定用户登录或者没登录时显示什么，用法如下：</p>
<pre class="hljs"><code><div>  &lt;Auth
    login={({userName}) =&gt; &lt;h1&gt;Hello {userName}&lt;/h1&gt;}
    nologin={() =&gt; &lt;h1&gt;Please login&lt;/h1&gt;}
  /&gt;
 

</div></code></pre>
<h2 id="%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</h2>
<p>render props 其实就是 React 世界中的“依赖注入”（Dependency Injection)。</p>
<p>所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。</p>
<p>在上面的代码示例中，<code>Login</code> 和 <code>Auth</code> 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。</p>
<h2 id="render-props-%E5%92%8C%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83">render props 和高阶组件的比较</h2>
<p>我们来比对一下这两种重用 React 组件逻辑的模式。</p>
<p>首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。</p>
<p>render props 不像上一小节中介绍的高阶组件有那么多毛病，如果说 render props 有什么缺点，那就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。</p>
<p>render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如下：</p>
<pre class="hljs"><code><div>const withLogin = (Component) =&gt; {
  const NewComponent = (props) =&gt; {
    const userName= getUserName();
    if (userName) {
      return &lt;Component {...props} userName={userName}/&gt;;
    } else {
      return null;
    }
  }

  return NewComponent;
};

</div></code></pre>
<p>这就要求被 withLogin 包住的组件要接受 <code>userName</code> 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 <code>name</code> 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 <code>userName</code> 到 <code>name</code> 的映射，十分费事。</p>
<p>对于应用 render props 的 Login，就不存在这个问题，接受 <code>name</code> 不接受 <code>userName</code> 是吗？这样写就好了：</p>
<pre class="hljs"><code><div>
&lt;Login&gt;
  {
    (props) =&gt; {
      const {userName} = props;
      return &lt;TheComponent {...props} name={userName} /&gt;
    }
  }
&lt;/Login&gt;


</div></code></pre>
<p>所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。</p>
<p>这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>在这一小节中，我们介绍了 render props 这种模式，也将 render props 和高阶组件两种模式进行了比较。</p>
<p>读者应该要明白:</p>
<ol>
<li>render props 的形式；</li>
<li>render props 其实就是“依赖注入”；</li>
<li>如何利用 render props 实现共享组件之间的逻辑。</li>
</ol>

</body>
</html>
