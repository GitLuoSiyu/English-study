<!DOCTYPE html>
<html>
<head>
<title>React 状态管理（1）：组件状态.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="react-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81">React 状态管理（1）：组件状态</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>在前面的章节中，我们反复声明过 React 其实就是这样一个公式：</p>
<pre class="hljs"><code><div>UI = f(data)

</div></code></pre>
<p>f 的参数 data，除了 props，就是 state。props 是组件外传递进来的数据，state 代表的就是 React 组件的内部状态。</p>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BA%86%E8%A7%A3-react-%E7%BB%84%E4%BB%B6%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">为什么要了解 React 组件自身状态管理</h2>
<p>可能读者也知道在 React 开发社区中 Redux 和 Mobx 这样的状态管理工具，不过，我们首先不要管这些第三方工具，先从了解 React 组件自身的管理开始。</p>
<p>为什么呢？</p>
<p>第一个原因，因为 React 组件自身的状态管理是基础，其他第三方工具都是在这个基础上构筑的，连基础都不了解，无法真正理解第三方工具。</p>
<p>另一个重要原因，对于很多应用场景，React 组件自身的状态管理就足够解决问题，犯不上动用 Redux 和 MobX 这样的大杀器，简单问题简单处理，可以让代码更容易维护。</p>
<h2 id="%E7%BB%84%E4%BB%B6%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81-state">组件自身状态 state</h2>
<h3 id="%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E6%94%BE%E5%9C%A8-state-%E4%B8%AD">什么数据放在 state 中</h3>
<p>对于 React 组件而言，数据分为两种：</p>
<ol>
<li>props</li>
<li>state</li>
</ol>
<p>二者的区别显而易见，简单说就是，props 是外部传给组件的数据，而 state 是组件自己维护的数据，对外部是不可见的。</p>
<p>所以，判断某个数据以 props 方式存在，还是以 state 方式存在，并不难，只需要判断这个状态是否是组件内部状态。</p>
<p>一个经常被问到的问题，就是为什么不把组件的数据直接存放在组件类的成员变量中？比如像下面这样：</p>
<pre class="hljs"><code><div>class Foo extends React.Component {
  foo = 'foo'
  
  render() {
    return (
      &lt;React.Fragment&gt;{this.foo}&lt;/React.Fragment&gt;
    );
  }
}


</div></code></pre>
<p>像上面，数据存在 <code>this.foo</code> 中，而不是存在 <code>this.state.foo</code> 中，当这个组件渲染的时候，当然 <code>this.foo</code> 的值也就被渲染出来了，问题是，更新 <code>this.foo</code> 并不会引发组件的重新渲染，这很可能不是我们想要的。</p>
<p>所以，判断一个数据应该放在哪里，用下面的原则：</p>
<ol>
<li>如果数据由外部传入，放在 props 中；</li>
<li>如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 state 中；不是，放在成员变量中。</li>
</ol>
<h3 id="%E4%BF%AE%E6%94%B9-state-%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F">修改 state 的正确方式</h3>
<p>组件自身的状态可以通过 <code>this.state</code> 读到，<code>this.state</code> 本身就是一个对象，但是修改状态不应该通过直接修改 <code>this.state</code> 对象来完成。因为，我们修改 state，当然不只是想修改这个对象的值，而是想引发 React 组件的重新渲染。</p>
<pre class="hljs"><code><div>this.state.foo = 'bar'; //错误的方式

this.setState({foo:'bar'}); //正确的方式

</div></code></pre>
<p>如上面代码所示，如果只是修改 <code>this.state</code>，那改了也就只是改了这个对象，其他的什么都不会发生；如果使用 <code>setState</code> 函数，那不光修改 <code>state</code>，还能引发组件的重新渲染，在重新渲染中就会使用修改后的 <code>state</code>，这也就是达到根据 <code>state</code> 改变公式左侧 UI 的目的。</p>
<pre class="hljs"><code><div>UI = f(state)

</div></code></pre>
<h3 id="state-%E6%94%B9%E5%8F%98%E5%BC%95%E5%8F%91%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA">state 改变引发重新渲染的时机</h3>
<p>现在我们知道应该用 <code>setState</code> 函数来修改组件 state，而且可以引发组件重新渲染，有意思的是，并不是一次 <code>setState</code> 调用肯定会引发一次重新渲染。</p>
<p>这是 React 的一种性能优化策略，如果 React 对每一次 <code>setState</code> 都立刻做一次组件重新渲染，那代价有点大，比如下面的代码：</p>
<pre class="hljs"><code><div>this.setState({count: 1});
this.setState({caption: 'foo'});
this.setState({count: 2});

</div></code></pre>
<p>连续的同步调用 <code>setState</code>，第三次还覆盖了第一次调用的效果，但是效果只相当于调用了下面这样一次：</p>
<pre class="hljs"><code><div>this.setState({count: 2, caption: 'foo'});

</div></code></pre>
<p>虽然明智的开发者不会故意连续写三个 setState 调用，但是代码一旦写得复杂，可能有多个 setState 分布在一次执行的不同代码片段中，还是会同步连续调用 setState，这时候，如果真的每个 setState 都引发一次重新渲染，实在太浪费了。</p>
<p>React 非常巧妙地用任务队列解决了这个问题，可以理解为每次 setState 函数调用都会往 React 的任务队列里放一个任务，多次 setState 调用自然会往队列里放多个任务。React 会选择时机去批量处理队列里执行任务，当批量处理开始时，React 会合并多个 setState 的操作，比如上面的三个 setState 就被合并为只更新 state 一次，也只引发一次重新渲染。</p>
<p>因为这个任务队列的存在，React 并不会同步更新 state，所以，在 React 中，setState 也不保证同步更新 state 中的数据。</p>
<h3 id="state-%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%90%8C%E6%AD%A5%E4%BF%AE%E6%94%B9">state 不会被同步修改</h3>
<p>简单说来，调用 setState 之后的下一行代码，读取 this.state 并不是修改之后的结果。</p>
<pre class="hljs"><code><div>  console.log(this.state.count);// 修改之前this.state.count为0
  this.setState({count: 1})
  console.log(this.state.count);// 在这里this.state.count依然为0

</div></code></pre>
<p>这乍看是很让人费解的结果，但是如果你理解了上面 React 任务队列的设计，一切也不难理解。</p>
<p>setState 只是给任务队列里增加了一个修改 this.state 的任务，这个任务并没有立即执行，所以 this.state 并不会立刻改变。</p>
<p>好吧，其实问题也没有那么简单，上面我所举的例子中，都假设 setState 是由 React 的生命周期函数或者事件处理函数中同步调用，这种情况下 setState 不会立即同步更新 state 和重新渲染，但是，如果调用 setState 由其他条件引发，就不是这样了。</p>
<p>看下面的代码，结果可能会出乎你的所料：</p>
<pre class="hljs"><code><div>  setTimeout(() =&gt; {
    this.setState({count: 2}); //这会立刻引发重新渲染
    console.log(this.state.count); //这里读取的count就是2
  }, 0);

</div></code></pre>
<p>为什么 setTimeout 能够强迫 setState 同步更新 state 呢？</p>
<p>可以这么理解，当 React 调用某个组件的生命周期函数或者事件处理函数时，React 会想：“嗯，这一次函数可能调用多次 setState，我会先打开一个标记，只要这个标记是打开的，所有的 setState 调用都是往任务队列里放任务，当这一次函数调用结束的时候，我再去批量处理任务队列，然后把这个标记关闭。”</p>
<p>因为 setTimeout 是一个 JavaScript 函数，和 React 无关，对于 setTimeout 的第一个函数参数，这个函数参数的执行时机，已经不是 React 能够控制的了，换句话说，React 不知道什么时候这个函数参数会被执行，所以那个“标记”也没有打开。</p>
<p>当那个“标记”没有打开时，setState 就不会给任务列表里增加任务，而是强行立刻更新 state 和引发重新渲染。这种情况下，React 认为：“这个 setState 发生在自己控制能力之外，也许开发者就是想要强行同步更新呢，宁滥勿缺，那就同步更新了吧。”</p>
<p>知道这个“技巧”之后，可能会有开发者说：好啊，那么以后我就用 setTimeout 来调用 setState 吧，能够立刻更新 state，多好！</p>
<p>我劝你不要这么做。</p>
<p>就像上面所说，React 选择不同步更新 state，是一种性能优化，如果你用上 setTimeout，就没机会让 React 优化了。</p>
<p>而且，每当你觉得需要同步更新 state 的时候，往往说明你的代码设计存在问题，绝大部分情况下，你所需要的，并不是“state 立刻更新”，而是，“确定 state 更新之后我要做什么”，这就引出了 setState 另一个功能。</p>
<h3 id="setstate-%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0">setState 的第二个参数</h3>
<p>setState 的第二个参数可以是一个回调函数，当 state 真的被修改时，这个回调函数会被调用。</p>
<pre class="hljs"><code><div>  console.log(this.state.count); // 0
  this.setState({count: 1}, () =&gt; {
    console.log(this.state.count); // 这里就是1了
  })
  console.log(this.state.count); // 依然为0

</div></code></pre>
<p>当 setState 的第二个参数被调用时，React 已经处理完了任务列表，所以 this.state 就是更新后的数据。</p>
<p>如果需要在 state 更新之后做点什么，请利用第二个参数。</p>
<h3 id="%E5%87%BD%E6%95%B0%E5%BC%8F-setstate">函数式 setState</h3>
<p>不管怎么说，setState 不能同步更新的确会带来一些麻烦，尤其是多个 setState 调用之间有依赖关系的时候，很容易写错代码。</p>
<p>一个很典型的例子，当我们不断增加一个 state 的值时：</p>
<pre class="hljs"><code><div>  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});

</div></code></pre>
<p>上面的代码表面上看会让 this.state.count 增加 3，实际上只增加了 1，因为 setState 没有同步更新 this.state 啊，所以给任务队列加的三个任务都是给 this.state.count 同一个值而已。</p>
<p>面对这种情况，我们很自然地想到，如果任务列表中的任务不只是给 state 一个固定数据，如果任务列表里的“任务”是一个函数，能够根据当前 state 计算新的状态，那该多好！</p>
<p>实际上，setState 已经支持这种功能，到现在为止我们给 setState 的第一个参数都是对象，其实也可以传入一个函数。</p>
<p>当 setState 的第一个参数为函数时，任务列表上增加的就是一个可执行的任务函数了，React 每处理完一个任务，都会更新 this.state，然后把新的 state 传递给这个任务函数。</p>
<p>setState 第一个参数的形式如下：</p>
<pre class="hljs"><code><div>function increment(state, props) {
  return {count: state.count + 1};
}

</div></code></pre>
<p>可以看到，这是一个纯函数，不光接受当前的 state，还接受组件的 props，在这个函数中可以根据 state 和 props 任意计算，返回的结果会用于修改 this.state。</p>
<p>如此一来，我们就可以这样连续调用 setState：</p>
<pre class="hljs"><code><div>  this.setState(increment);
  this.setState(increment);
  this.setState(increment);

</div></code></pre>
<p>用这种函数式方式连续调用 setState，就真的能够让 this.state.count 增加 3，而不只是增加 1。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>通过这一小节，读者应该能够明白：</p>
<ol>
<li>如何确定数据以 props 还是以 state 形式存在；</li>
<li>更新 state 的正确方法；</li>
<li>setState 通常并不会立刻更新 state；</li>
<li>函数参数形式的 setState 才是推荐的用法。</li>
</ol>

</body>
</html>
