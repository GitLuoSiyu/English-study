<!DOCTYPE html>
<html>
<head>
<title>React 单元测试.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">React 单元测试</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>这一小节来讲 React 中的测试，虽然不涉及 React 的使用，但是却关系到我们开发的 React 的质量。</p>
<p>毫无疑问，对代码进行测试是最佳实践，可以保证代码质量，不过，对于软件代码质量毫不关心的读者可以略过这一节。</p>
<h2 id="%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E7%9A%84">测试的目的</h2>
<p>测试对于软件开发非常重要，简单来说，测试就是尽力发现软件中的缺陷（俗称 bug），当我们发现不了更多的 bug 时，说明这个软件质量可以接受了。</p>
<p>然而，没有 bug 的软件我还没见过呢。</p>
<p>在互联网时代，我们更是不可能等到所有 bug 都修复了才上线，那样黄花菜都凉了，稍微有一些工作经验的人都会有这样的体会。</p>
<p>所以，事实上，测试是<strong>尽力</strong>发现软件中的 bug。当我们发现 bug 数量和严重程度呈稳定的下降趋势，直到低于一个门槛（无须降低为 0，只需要降低到可接受的程度），没有更多更严重的 bug 出现，就说明这个软件的质量可以接受，可以上线了。</p>
<p>这样当然要比达到“零 bug 软件”要容易多了，但是，不要因此以为这就是一件没有困难的任务。为了让 bug 的数量和严重程度足够低，我们开发者必须严格要求自己，只有保证我们写的每一小块代码都经受住测试的考验，这些小块代码集合在一起的时候才可能（只是有可能）不会出很多 bug，如果我们写的小块代码质量都无法保证，那大项目的代码根本无法保证。</p>
<p>这一小节重点讲对”小块代码“的测试，也就是单元测试。</p>
<h2 id="%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</h2>
<p>单元测试的内容足够讲一本书了，所以，我只针对性地讲一讲 React 组件的单元测试，并且只有三个要点：</p>
<ol>
<li>用 Jest；</li>
<li>用 Enzyme；</li>
<li>保持 100% 的代码覆盖率。</li>
</ol>
<h3 id="jest">Jest</h3>
<p>在 JavaScript 的世界里，单元测试的框架很多，品牌最老名气最响的是 <a href="https://mochajs.org/">Mocha</a> ，不过，不要纠结于名气，请使用 <a href="https://jestjs.io/">Jest</a> 。你不会后悔的，接下来我告诉你为什么。</p>
<p>我们先假设，作为开发者，你是在团队中工作。所谓团队，就是有很多人一起工作，而且随着业务和团队的发展，人会越来越多，潜台词就是——不确定因素越来越多。</p>
<p>人和人之间交流会出现偏差，人的水平有高低之分，人也会犯错，总之，你不能指望所有人都把事情做得尽善尽美。</p>
<p>具体到单元测试这件事上来，“测试驱动”是开发喊了这么多年，为什么真正做到这一点的团队依然不多呢？因为，当团队变大之后，很多问题也就出现了。</p>
<ol>
<li><strong>单元测试用例庞大，执行时间过长</strong>。</li>
</ol>
<p>想象一下，一个代码库里假设有一千个单元测试用例，即使每个单元测试用例平均只需要 10 毫秒，那总时间也就需要 10 秒钟。好，假设代码库进一步扩大，有了一万个单元测试用例，那就跑一遍就需要 100 秒，已经超过了一分钟。这还只是保守估计，实际上单元测试用例的运行时间只会比这长。开发者如果每次修改都需要等待这么漫长的单元测试运行时间，肯定会三心二意上网去看其他东西。</p>
<ol start="2">
<li><strong>单元测试用例之间相互影响</strong>。</li>
</ol>
<p>你可能也有这样的体验，代码库中的单元测试突然失败了，但是你修改的代码根本不会取影响失败的那个单元测试用例，怎么回事？这往往是因为某个成员以前的代码写得不好，影响了一个全局变量。当然，谁都知道单元测试应该在 setup 时创建环境，在 teardown 时恢复环境，可是，总会有人有马虎大意的情况，这时候你怎么办？要么你只好去修复一个本不是你改坏的代码，要么你干脆删掉那段不可靠的单元测试代码，不管怎样，这都会打击你支持“测试驱动开发”的决心。</p>
<p>Jest 较好地解决了上面说的问题，因为 Jest 最重要的一个特性，就是支持并行执行。</p>
<p>Mocha 之类老牌单元测试框架，把所有的单元测试都放在一个环境中执行，这就使所有单元测试访问的是同样一个全局变量空间，所以只要测试代码没写好，就会互相影响。而且，为了保证执行正常，所有的单元测试必须一个接一个地执行，这是体系架构决定的，没有办法。</p>
<p>Jest 不同，Jest 为每一个单元测试文件创造一个独立的运行环境，换句话说，Jest 会启动一个进程执行一个单元测试文件，运行结束之后，就把这个执行进程废弃了，这个单元测试文件即使写得比较差，把全局变量污染得一团糟，也不会影响其他单元测试文件，因为其他单元测试文件是用另一个进程来执行。</p>
<p>更妙的是，因为每个单元测试文件之间再无纠葛，Jest 可以启动多个进程同时运行不同的文件，这样就充分利用了电脑的多 CPU 多核，单进程 100 秒才完成的测试执行过程，8 核只需要 12.5 秒，速度快了很多。</p>
<p>Jest 还有很多其他友好的特性，大家可以自己去发掘，这里废话不多说，只想安利各位，<strong>测试 React 或者 JavaScript 代码，用 Jest！</strong></p>
<p>使用 create-react-app 产生的项目自带 Jest 作为测试框架，不奇怪，因为 Jest 和 React 一样都是出自 Facebook。</p>
<p>运行下面的命令，就可以进入交互式的”测试驱动开发“模式：</p>
<pre class="hljs"><code><div>npm test

</div></code></pre>
<h3 id="enzyme">Enzyme</h3>
<p>虽然最好的 React 测试框架出自 Facebook 家，最受欢迎的 React 测试工具库却出自 Airbnb，这个工具库叫做 Enzyme。Enzyme 这个单词的含义是“酶”，至于命名原因已经无法考据，可能寓意着快速分解。</p>
<p>不过因为 Enzyme 不是 Facebook 家出品，所以使用 Enzyme 还真稍微有些麻烦——在 create-react-app 产生的应用中并不包含 Enzyme，需要我们自己来添加。</p>
<p>在项目目录下，通过下面的命令来安装 <code>enzyme</code>：</p>
<pre class="hljs"><code><div>npm i --save-dev enzyme enzyme-adapter-react-16

</div></code></pre>
<p>可以注意到，我们不光要安装 enzyme，还要安装 <code>enzyme-adapter-react-16</code>，这个库是用来作为适配器的。因为不同 React 版本有各自特点，所用的适配器也会不同，我们的项目中使用的是 16.4 之后的版本，所以用 <code>enzyme-adapter-react-16</code>；如果用 16.3 版本，需要用 <code>enzyme-adapter-react-16.3</code>；如果用 16.2 版本，需要用 <code>enzyme-adapter-react-16.2</code>；如果用更老的版本 15.5，需要用 <code>enzyme-adapter-react-15</code>。具体各个 React 版本对应什么样的 Adapter，请参考 <a href="https://airbnb.io/enzyme/#installation">enzyme官方文档</a>。</p>
<p>现在，可以在测试代码中使用 enzyme 了。我们以之前秒表应用中的 ControlButtons 组件为例，来说明如何做单元测试。</p>
<p>我们创造一个 <code>ControlButtons.test.js</code>，来容纳对应的测试用例，因为所有后缀为 <code>.test.js</code> 的文件都会被 Jest 认作是测试用例文件。</p>
<p>在代码中，需要使用 Adapter，代码如下：</p>
<pre class="hljs"><code><div>import {configure} from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
configure({adapter: new Adapter()});

</div></code></pre>
<p>我们对 ControlButtons 组件的测试，就是要渲染它一次，看看渲染结果如何，enzyme 就能帮助我们做这件事。</p>
<p>比如，我们想要保证渲染出来的内容必须包含两个按钮，其中一个按钮的 class 名是 <code>left-btn</code>，另一个是 <code>right-btn</code>，那么我们就需要下面的单元测试用例：</p>
<pre class="hljs"><code><div>import {shallow} from 'enzyme';

it('renders without crashing', () =&gt; {
  const wrapper = shallow(&lt;ControlButtons /&gt;);
  expect(wrapper.find('.left-btn')).toHaveLength(1);
  expect(wrapper.find('.right-btn')).toHaveLength(1);
});

</div></code></pre>
<p>在这里我们使用了 <code>shallow</code>，其实也可以使用 <code>mount</code>。</p>
<p>shallow 和 mount 的区别，就是 shallow 只会渲染被测试的 React 组件这一层，不会渲染子组件；而 mount 则是完整地渲染 React 组件包括其所有子组件，包括触发 <code>componentDidMount</code> 生命周期函数。</p>
<p>原则上，能用 shallow 就尽量用 shallow，首先是为了测试性能考虑，其次是可以减少组件之间的影响，比如，一个组件 <code>Foo</code> 有子组件 <code>Bar</code>，如下：</p>
<pre class="hljs"><code><div>const Foo = () =&gt; ()
    &lt;div&gt;
       {/* other logic */
       &lt;Bar /&gt;
    &lt;/div&gt;
)

</div></code></pre>
<p>如果用 mount 去渲染 Foo，会连带 Bar 一起完全渲染，如果 Bar 出了什么毛病，那 Foo 的单元测试也过不了；如果用 shallow，只知道 Bar 曾经被用，即使 Bar 哪里出了问题，也不影响 Foo 的单元测试。</p>
<p>这并不是说我们就不管 Bar，Bar 的质量会由它自己的单元测试来检验，这就引出下一个话题——代码覆盖率。</p>
<h3 id="%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87">代码覆盖率</h3>
<p>你不能给自己的程序随便写几个单元测试，就说自己的代码已经测试好了，就像上面我只给 ControlButtons 组件写了一个测试用例，我并不能说整个秒表应用已经通过了测试。</p>
<p>你的代码测试覆盖率只有达到一定程度，才好说自己的代码已经被测试了。</p>
<p>剩下来就是一个纠结的问题：代码测试的覆盖率应该达到多少才算够？</p>
<p>以我个人的经验，代码覆盖率必须达到 100%，也就是说，一个应用不光所有的单元测试都要通过，而且所有单元测试都必须覆盖到代码 100% 的角落。</p>
<p>如果对覆盖率的要求低于 100%，时间一长，质量必定会越来越下滑。</p>
<p>遇到一个不好测试的代码，开发者倾向于不去考虑如何重构代码提高可测试性，而是直接忽略这部分代码不去测试，反正不要求 100% 嘛；遇到工期比较紧的时候，甚至会进一步降低代码覆盖率要求，用牺牲质量来加快开发速度，反正不要求 100% 嘛。</p>
<p>所以，如果你真的对代码质量认真负责的话，请坚守 100% 代码覆盖率的底线！</p>
<p>在 create-react-app 创造的应用中，已经自带了代码覆盖率的支持，运行下面的命令，不光会运行所有单元测试，也会得到覆盖率汇报。</p>
<pre class="hljs"><code><div>npm test -- --coverage

</div></code></pre>
<p>代码覆盖率包含四个方面：</p>
<ol>
<li>语句覆盖率</li>
<li>逻辑分支覆盖率</li>
<li>函数覆盖率</li>
<li>代码行覆盖率</li>
</ol>
<p>只有四个方面都是 100%，才算真的 100%。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>这一小节相对较为简略，这是有原因的。虽然我可以讲解很详细的单元测试工具使用方法，但是这并不是最重要的，最重要也最困难的是具有质量意识。</p>
<p>如果你具备质量意识，只需要强调上面说的 3 点，你就知道该怎么做，不需要我多说你也会找到对应的使用方法；相反，如果你不具备质量意识，说遍所有测试技巧，你也不会去实践，多说无益。</p>
<p>就像我在本节开始所说的，如果你根本不在意软件质量，完全可以忽略掉这一小节。</p>

</body>
</html>
