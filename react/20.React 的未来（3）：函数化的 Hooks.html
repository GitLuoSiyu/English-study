<!DOCTYPE html>
<html>
<head>
<title>React 的未来（3）：函数化的 Hooks.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="react-%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%883%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E5%8C%96%E7%9A%84-hooks">React 的未来（3）：函数化的 Hooks</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>这一节我们来介绍 Hooks，React v16.7.0-alpha 中第一次引入了 <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> 的概念，因为这是一个 alpha 版本，不算正式发布，所以，将来正式发布时 API 可能会有变化。</p>
<p><strong>Hooks 的目的，简而言之就是让开发者不需要再用 class 来实现组件</strong>。</p>
<p>还记得之前我们介绍的经典 Counter 组件吗？不考虑用 Redux 或者 Mobx 来管理状态的话，Counter 组件就需要把计数数据放在 state 里，要用 state，就意味着需要定义一个 class。</p>
<p>很多时候，一个简单组件也需要实现一个 class，的确是一件很烦的事，有了 Hooks 之后，事情就简单多了，我们用几个已经公开的 Hooks API 来看看如何避免写 class。</p>
<h2 id="usestate">useState</h2>
<p>Hooks 会提供一个叫 <code>useState</code> 的方法，它开启了一扇新的定义 state 的门，对应 Counter 的代码可以这么写：</p>
<pre class="hljs"><code><div>import { useState } from 'react';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
       &lt;div&gt;{count}&lt;/div&gt;
       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
       &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
};

</div></code></pre>
<p>注意看，Counter 拥有自己的“状态”，但它只是一个函数，不是 class。</p>
<p><code>useState</code> 只接受一个参数，也就是 state 的初始值，它返回一个只有两个元素的数组，第一个元素就是 state 的值，第二个元素是更新 state 的函数。</p>
<p>我们利用解构赋值（destructuring assignment）把两个元素分别赋值给 count 和 setCount，相当于这样的代码：</p>
<pre class="hljs"><code><div>  // 下面代码等同于： const [count, setCount] = useState(0);
  const result = useState(0);
  const count = result[0];
  const setCount = result[1];

</div></code></pre>
<p>利用 <code>count</code> 可以读取到这个 state，利用 <code>setCount</code> 可以更新这个 state，而且我们完全可以控制这两个变量的命名，只要高兴，你完全可以这么写:</p>
<pre class="hljs"><code><div>  const [theCount, updateCount] = useState(0);

</div></code></pre>
<p>因为 <code>useState</code> 在 <code>Counter</code> 这个函数体中，每次 Counter 被渲染的时候，这个 <code>useState</code> 调用都会被执行，<code>useState</code> 自己肯定不是一个纯函数，因为它要区分第一次调用（组件被 mount 时）和后续调用（重复渲染时），只有第一次才用得上参数的初始值，而后续的调用就返回“记住”的 state 值。</p>
<p>读者看到这里，心里可能会有这样的疑问：如果组件中多次使用 <code>useState</code> 怎么办？React 如何“记住”哪个状态对应哪个变量？</p>
<p>React 是完全根据 <code>useState</code> 的调用顺序来“记住”状态归属的，假设组件代码如下：</p>
<pre class="hljs"><code><div>const Counter = () =&gt; {
  const [count, setCount] = useState(0);
  const [foo, updateFoo] = useState('foo');
  
  ...
}

</div></code></pre>
<p>每一次 Counter 被渲染，都是第一次 <code>useState</code> 调用获得 <code>count</code> 和 <code>setCount</code>，第二次 <code>useState</code> 调用获得 <code>foo</code> 和 <code>updateFoo</code>（这里我故意让命名不用 <code>set</code> 前缀，可见函数名可以随意）。React 是渲染过程中的“上帝”，每一次渲染 Counter 都要由 React 发起，所以它有机会准备好一个内存记录，当开始执行的时候，每一次 useState 调用对应内存记录上一个位置，而且是按照顺序来记录的。React 不知道你把 <code>useState</code> 等 Hooks API 返回的结果赋值给什么变量，但是它也不需要知道，它只需要按照 <code>useState</code> 调用顺序记录就好了。</p>
<p>正因为这个原因，<strong>Hooks，千万不要在 if 语句或者 for 循环语句中使用！</strong></p>
<p>像下面的代码，肯定会出乱子的：</p>
<pre class="hljs"><code><div>const Counter = () =&gt; {
    const [count, setCount] = useState(0);
    if (count % 2 === 0) {
        const [foo, updateFoo] = useState('foo');
    }
    const [bar, updateBar] = useState('bar');
  ...
}

</div></code></pre>
<p>因为条件判断，让每次渲染中 <code>useState</code> 的调用次序不一致了，于是 React 就错乱了。</p>
<h2 id="useeffect">useEffect</h2>
<p>除了 <code>useState</code>，React 还提供 <code>useEffect</code>，用于支持组件中增加副作用的支持。</p>
<p>在 React 组件生命周期中如果要做有副作用的操作，代码放在哪里？</p>
<p>当然是放在 componentDidMount 或者 componentDidUpdate 里，但是这意味着组件必须是一个 class。</p>
<p>在 Counter 组件，如果我们想要在用户点击“+”或者“-”按钮之后把计数值体现在网页标题上，这就是一个修改 DOM 的副作用操作，所以必须把 Counter 写成 class，而且添加下面的代码：</p>
<pre class="hljs"><code><div>componentDidMount() {
  document.title = `Count: ${this.state.count}`;
}

componentDidUpdate() {
  document.title = `Count: ${this.state.count}`;
}

</div></code></pre>
<p>而有了 <code>useEffect</code>，我们就不用写一个 class 了，对应代码如下：</p>
<pre class="hljs"><code><div>import { useState, useEffect } from 'react';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);
  
  useEffect(() =&gt; {
    document.title = `Count: ${count}`;
  });

  return (
    &lt;div&gt;
       &lt;div&gt;{count}&lt;/div&gt;
       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
       &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
};

</div></code></pre>
<p><code>useEffect</code> 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 componentDidMount 和 componentDidUpdate 一样的效果。</p>
<p>虽然本质上，依然是 componentDidMount 和 componentDidUpdate 两个生命周期被调用，但是现在我们关心的不是 mount 或者 update 过程，而是“after render”事件，<code>useEffect</code> 就是告诉组件在“渲染完”之后做点什么事。</p>
<p>读者可能会问，现在把 componentDidMount 和 componentDidUpdate 混在了一起，那假如某个场景下我只在 mount 时做事但 update 不做事，用 useEffect 不就不行了吗？</p>
<p>其实，用一点小技巧就可以解决。<code>useEffect</code> 还支持第二个可选参数，只有同一 <code>useEffect</code> 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 <code>componentDidMount</code>，只需要这样写：</p>
<pre class="hljs"><code><div>  useEffect(() =&gt; {
    // 这里只有mount时才被调用，相当于componentDidMount
  }, [123]);

</div></code></pre>
<p>在上面的代码中，<code>useEffect</code> 的第二个参数是 <code>[123]</code>，其实也可以是任何一个常数，因为它永远不变，所以 <code>useEffect</code> 只在 mount 时调用第一个函数参数一次，达到了 componentDidMount 一样的效果。</p>
<h2 id="usecontext">useContext</h2>
<p>在前面介绍“提供者模式”章节我们介绍过 React 新的 Context API，这个 API 不是完美的，在多个 Context 嵌套的时候尤其麻烦。</p>
<p>比如，一段 JSX 如果既依赖于 ThemeContext 又依赖于 LanguageContext，那么按照 React Context API 应该这么写：</p>
<pre class="hljs"><code><div>&lt;ThemeContext.Consumer&gt;
    {
        theme =&gt; (
            &lt;LanguageContext.Cosumer&gt;
                language =&gt; {
                    //可以使用theme和lanugage了
                }
            &lt;/LanguageContext.Cosumer&gt;
        )
    }
&lt;/ThemeContext.Consumer&gt;

</div></code></pre>
<p>因为 Context API 要用 render props，所以用两个 Context 就要用两次 render props，也就用了两个函数嵌套，这样的缩格看起来也的确过分了一点点。</p>
<p>使用 Hooks 的 <code>useContext</code>，上面的代码可以缩略为下面这样：</p>
<pre class="hljs"><code><div>const theme = useContext(ThemeContext);
const language = useContext(LanguageContext);
// 这里就可以用theme和language了

</div></code></pre>
<p>这个<code>useContext</code>把一个需要很费劲才能理解的 Context API 使用大大简化，不需要理解render props，直接一个函数调用就搞定。</p>
<p>但是，<code>useContext</code>也并不是完美的，它会造成意想不到的重新渲染，我们看一个完整的使用<code>useContext</code>的组件。</p>
<pre class="hljs"><code><div>const ThemedPage = () =&gt; {
    const theme = useContext(ThemeContext);
    
    return (
       &lt;div&gt;
            &lt;Header color={theme.color} /&gt;
            &lt;Content color={theme.color}/&gt;
            &lt;Footer color={theme.color}/&gt;
       &lt;/div&gt;
    );
};

</div></code></pre>
<p>因为这个组件<code>ThemedPage</code>使用了<code>useContext</code>，它很自然成为了Context的一个消费者，所以，只要Context的值发生了变化，<code>ThemedPage</code>就会被重新渲染，这很自然，因为不重新渲染也就没办法重新获得<code>theme</code>值，但现在有一个大问题，对于ThemedPage来说，实际上只依赖于<code>theme</code>中的<code>color</code>属性，如果只是<code>theme</code>中的<code>size</code>发生了变化但是<code>color</code>属性没有变化，<code>ThemedPage</code>依然会被重新渲染，当然，我们通过给<code>Header</code>、<code>Content</code>和<code>Footer</code>这些组件添加<code>shouldComponentUpdate</code>实现可以减少没有必要的重新渲染，但是上一层的<code>ThemedPage</code>中的JSX重新渲染是躲不过去了。</p>
<p>说到底，<code>useContext</code>需要一种表达方式告诉React：“我没有改变，重用上次内容好了。”</p>
<p>希望Hooks正式发布的时候能够弥补这一缺陷。</p>
<h2 id="hooks-%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8F%E6%94%B9%E5%8F%98">Hooks 带来的代码模式改变</h2>
<p>上面我们介绍了 <code>useState</code>、<code>useEffect</code> 和 <code>useContext</code> 三个最基本的 Hooks，可以感受到，Hooks 将大大简化使用 React 的代码。</p>
<p>首先我们可能不再需要 class了，虽然 React 官方表示 class 类型的组件将继续支持，但是，业界已经普遍表示会迁移到 Hooks 写法上，也就是放弃 class，只用函数形式来编写组件。</p>
<p>对于 <code>useContext</code>，它并没有为消除 class 做贡献，却为消除 render props 模式做了贡献。很长一段时间，高阶组件和 render props 是组件之间共享逻辑的两个武器，但如同我前面章节介绍的那样，这两个武器都不是十全十美的，现在 Hooks 的出现，也预示着高阶组件和 render props 可能要被逐步取代。</p>
<p>但读者朋友，不要觉得之前学习高阶组件和 render props 是浪费时间，相反，你只有明白 React 的使用历史，才能更好地理解 Hooks 的意义。</p>
<p>可以预测，在 Hooks 兴起之后，共享代码之间逻辑会用函数形式，而且这些函数会以 <code>use-</code> 前缀为约定，重用这些逻辑的方式，就是在函数形式组件中调用这些 <code>useXXX</code> 函数。</p>
<p>例如，我们可以写这样一个共享 Hook <code>useMountLog</code>，用于在 mount 时记录一个日志，代码如下：</p>
<pre class="hljs"><code><div>const useMountLog = (name) =&gt; {
    useEffect(() =&gt; {
        console.log(`${name} mounted`);    
    }, [123]);
}

</div></code></pre>
<p>任何一个函数形式组件都可以直接调用这个 <code>useMountLog</code> 获得这个功能，如下：</p>
<pre class="hljs"><code><div>const Counter = () =&gt; {
    useMountLog('Counter');
    
    ...
}

</div></code></pre>
<p>对了，所有的 Hooks API 都只能在函数类型组件中调用，class 类型的组件不能用，从这点看，很显然，class 类型组件将会走向消亡。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>这一节我们介绍了 React Hooks，读者应该能够理解：</p>
<ol>
<li>Hooks 的意义就是可以淘汰 class 类型的组件；</li>
<li>Hooks 将改变重用组件逻辑的模式；</li>
<li>在未来，Hooks 将是 React 使用的主流。</li>
</ol>

</body>
</html>
