<!DOCTYPE html>
<html>
<head>
<title>组件实践（2）：组件的内部实现.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E7%BB%84%E4%BB%B6%E5%AE%9E%E8%B7%B5%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">组件实践（2）：组件的内部实现</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>上一小节中，通过设计一个“秒表”应用，我们学习了组件的接口定义的原则和方法，但那只是搭建了一个骨架，在这一小节中，我们就给这个骨架填充血肉，制造出能够运转的“秒表”。</p>
<p>我们不大可能一次就写出完美的代码，软件开发本来就是一个逐渐精进的过程，但是我们应该努力让代码达到这样的要求：</p>
<ol>
<li>功能正常；</li>
<li>代码整洁；</li>
<li>高性能。</li>
</ol>
<h2 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6">初始化应用框架</h2>
<p>我们使用 Facebook 提供的 create-react-app 来创建我们的 React 应用。严格说来，如果要开发一款真正大型的应用，用 create-react-app 并不合适，或者至少 create-react-app 的默认配置并不合适，真正的应用需要对 webpack 等做更精细的配置，但是，create-react-app 足够简单易用，从学习 React 的角度来看，真的是非常合适了。</p>
<p>如果你的机器上还没有安装 create-react-app，那么就使用下面的命令来全局安装：</p>
<pre class="hljs"><code><div>npm install -g create-react-app

</div></code></pre>
<p>然后，找一个合适的目录，使用下面的命令来创建我们的应用框架，在这里，我们的应用名字叫 <code>basic_stop_watch</code>。</p>
<pre class="hljs"><code><div>create-react-app basic_stop_watch --use-npm

</div></code></pre>
<p>create-react-app 会优先使用 yarn 来安装依赖的 npm 包，但是不知道读者机器上有没有安装 yarn，所以用 <code>--use-npm</code> 参数强制 create-react-app 使用传统的 npm 工具来安装依赖的包，这样能够保持一致。如果你更喜欢 yarn，不使用 <code>--use-npm</code> 这个参数就可以了。</p>
<p>创建应用框架需要花费一些时间，因为现在依赖的包实在太多太细碎了，在完成之后，会创建一个 <code>basic_stop_watch</code> 目录，进入这个目录，运行下面给的命令，就可以启动给一个基本的 React 应用。</p>
<pre class="hljs"><code><div>npm start

</div></code></pre>
<p>我们不会花费太多时间介绍 create-react-app 的其他功能和代码结构，因为我们有更重要的事情要做，那就是根据上一小节的组件设计来制造“秒表”相关组件。</p>
<h2 id="%E6%9E%84%E5%BB%BA-stopwatch">构建 StopWatch</h2>
<p>在上一小节中，我们已经确定了要用四个组件组合来实现“秒表”，这四个组件分别是 StopWatch、MajorClock、ControlButtons 和 SplitTimes。</p>
<p>我们在写代码之前要做的第一个决定就是，要把这些组件放在哪里？是放在不同的文件中？还是放在一个文件中就好？</p>
<p>表面上看，把所有组件放在一个文件中也行得通，但是，将来维护代码的朋友可能会很抓狂，想要修改 ControlButtons 这个组件，但是从文件目录里找不到对应文件，这样很不方便。</p>
<p>所以，从达到“代码整洁”的目的来说，应该每个组件都有一个独立的文件，然后这个文件用 <code>export default</code> 的方式导出单个组件。</p>
<p>比如，我们会在 <code>src</code> 目录下为 ControlButtons 创建一个 <code>ControlButtons.js</code> 文件，最初内容像下面这样：</p>
<pre class="hljs"><code><div>import React from 'react';

const ControlButtons = () =&gt; {
  //TODO: 实现ControlButtons
};

export default ControlButtons;

</div></code></pre>
<p>第一行导入 React，虽然目前没有派上什么用场，但是任何 JSX 都需要 React，很快我们在实现 ControlButtons 这个控件的内容时，就要写 JSX，所以导入 React 是必需的。</p>
<p>最后一行用 <code>export default</code> 的方式导出 ControlButtons，这样，在其他组件中就可以用下面的方式导入：</p>
<pre class="hljs"><code><div>import ControlButtons from './ControlButtons';

</div></code></pre>
<p>在上一节中我们已经设计好了 ControlButtons 可以接受的 props，我们重试 ControlButtons 的实现代码，如下：</p>
<pre class="hljs"><code><div>const ControlButtons = (props) =&gt; {
  const {activated, onStart, onPause, onReset, onSplit} = props;
  if (activated) {
    return (
      &lt;div&gt;
        &lt;button onClick={onSplit}&gt;计次&lt;/button&gt;
        &lt;button onClick={onPause}&gt;停止&lt;/button&gt;
      &lt;/div&gt;
    );
  } else {
    return (
      &lt;div&gt;
        &lt;button onClick={onReset}&gt;复位&lt;/button&gt;
        &lt;button onClick={onStart}&gt;启动&lt;/button&gt;
      &lt;/div&gt;
    );
  }
};

</div></code></pre>
<p>在这里用了一个 ES6 功能，叫做<strong>解构赋值</strong>（Destructuring Assignment）。因为 ControlButtons 是一个函数类型的组件，所以 props 以参数形式传递进来，props 中的属性包含 <code>activated</code> 这样的值，利用大括号，就可以完成对 props 的“解构”，把 props.activated 赋值给同名的变量 <code>activated</code>。</p>
<p>如果没有解构赋值，就只能用下面的代码，很明显，与使用了解构赋值的代码相比，真是啰嗦得让人难以忍受。</p>
<pre class="hljs"><code><div>  const activated = props.activated;
  const onStart = props.onStart;
  const onPause = props.onPause;
  const onReset = props.onReset;
  const onSplit = props.onSplit;


</div></code></pre>
<p>我们可以更进一步，把解构赋值提到参数中，这样连 props 的对象都看不见，就像下面这样：</p>
<pre class="hljs"><code><div>const ControlButtons = ({activated, onStart, onPause, onReset, onSplit}) =&gt; {

}

</div></code></pre>
<p>在 ControlButtons 的实现部分，我们根据 activated 的值返回不同的 JSX，当 activated 为 <code>true</code> 时，返回的是“计次”和“停止”；当 activated 为 <code>false</code> 时，返回的是“复位”和“启动”，对应分别使用了传入的 <code>on</code> 开头的函数类型 props。</p>
<p>可以看到，ControlButtons 除了显示内容和分配 props，没有做什么实质的工作，实质工作会在 StopWatch 中介绍。</p>
<p>接下来我们做 MajorClock，根据传入 props 的 milliseconds 来显示数字时钟一样的时分秒。在 MajorClock.js 文件中，我们这样定义 MajorClock：</p>
<pre class="hljs"><code><div>const MajorClock = ({milliseconds=0}) =&gt; {
  return &lt;h1&gt;{ms2Time(milliseconds)}&lt;/h1&gt;
};

</div></code></pre>
<p>在这里，我们不光直接解构了参数，而且使用了默认值。如果使用 MajorClock 时没有传入 <code>milliseconds</code> 这个 props，那么 <code>milliseconds</code> 的值就是 <code>0</code>。</p>
<p>因为把毫秒数转为 <code>HH:mm:ss:mmm</code> 这样的格式和 JSX 没什么关系，所以，我们不在组件中直接编写，而是放在 <code>ms2Time</code> 函数中，<code>ms2Time</code> 就是 <code>ms-to-Time</code>，代码如下：</p>
<pre class="hljs"><code><div>import padStart from 'lodash/padStart';

const ms2Time = (milliseconds) =&gt; {
  let time = milliseconds;
  const ms = milliseconds % 1000;
  time = (milliseconds - ms) / 1000;
  const seconds = time % 60;
  time = (time - seconds) / 60;
  const minutes = time % 60;
  const hours = (time - minutes) / 60;

  const result = padStart(hours, 2, '0') + &quot;:&quot; + padStart(minutes, 2, '0') + &quot;:&quot; + padStart(seconds, 2, '0') + &quot;.&quot; + padStart(ms, 3, '0');
  return result;
}

</div></code></pre>
<p>通过逐步从 milliseconds 中抽取毫秒、秒、分、时的信息，最终拼出人类容易理解的时间。不过，为了和数字时钟显示一致，需要补齐，比如 2 秒 23 毫秒，显示成 <code>2:23</code> 可不好看，不够的位数要补上 0，显示成 <code>00:00:02:023</code> 。这个补齐的工作和 React 无关，我们也不深究，直接使用 <code>lodash</code> 中的 <code>padStart</code> 实现。</p>
<p>为了在项目中使用 <code>lodash</code>，请先用 npm 完成对应的库安装。</p>
<p>最后是 SplitTimes 这个组件，在 <code>SplitTimes.js</code> 这个文件中，我们需要这样定义 SplitTimes：</p>
<pre class="hljs"><code><div>import MajorClock from './MajorClock';

const SplitTimes = ({value=[]}) =&gt; {
  return value.map((v, k) =&gt; (
    &lt;MajorClock key={k} milliseconds={v} /&gt;
  ));
};

</div></code></pre>
<p>因为根据毫秒数显示数字时钟的功能在 MajorClock 中已经做到了，所以我们直接导入 MajorClock 使用就好，这符合“重用代码”的原则。</p>
<p>值得一提的是，利用循环或者数组 map 而产生的动态数量的 JSX 元件，必须要有 <code>key</code> 属性。这个 <code>key</code> 属性帮助 React 搞清楚组件的顺序，如果不用 <code>key</code>，那 React 会在开发模式下在 console 上输出红色警告。</p>
<p>一般来说，key 不应该取数组的序号，因为 key 要唯一而且稳定，也即是每一次渲染过程中，key 都能唯一标识一个内容。对于 StopWatch 这个例子，倒是可以直接使用数组序号，因为计次时间的数组顺序不会改变，使用数组序号足够唯一标识内容。</p>
<h2 id="stopwatch-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">StopWatch 状态管理</h2>
<p>在实现了 MajorClock、ControlButtons 和 SplitTimes 之后，我们需要把这些子组件串起来，这就是 StopWatch。</p>
<p>StopWatch 是一个有状态的组件，所以，不能只用一个函数实现，而是做成一个继承自 <code>React.Component</code> 的类，如下：</p>
<pre class="hljs"><code><div>class StopWatch extends React.Component {
  render() {
    return (
      &lt;Fragment&gt;
        &lt;MajorClock /&gt;
        &lt;ControlButtons /&gt;
        &lt;SplitTimes /&gt;
      &lt;/Fragment&gt;
    );
  }
}


</div></code></pre>
<p>对于一个 React 组件类，最少要有一个 <code>render</code> 函数实现，不过，上面的 <code>render</code> 只是一个大概的代码框架，引用了相关子组件，但是没有传入 props。</p>
<p>传入什么 props 呢？当然是 StopWatch 记录的 state。</p>
<p>StopWatch 的 state 需要有这些信息：</p>
<ol>
<li>isStarted，是否开始计时；</li>
<li>startTime，计时开始时间，Date 对象；</li>
<li>currentTime，当前时间，也是 Date 对象；</li>
<li>splits，所有计次时间的数组，每个元素是一个毫秒数。</li>
</ol>
<p>React 组件的 state 需要初始化，一般来说，初始化 state 是在构造函数中，代码如下：</p>
<pre class="hljs"><code><div>  constructor() {
    super(...arguments);

    this.state = {
      isStarted: false,
      startTime: null,
      currentTime: null,
      splits: [],
    };
  }
 

</div></code></pre>
<p>如果定义构造函数 constructor，一定要记得通过 super 调用父类 <code>React.Component</code> 的构造函数，不然，功能会不正常。</p>
<p>React官方网站上的代码示例是这样调用super函数：</p>
<pre class="hljs"><code><div>  constructor(props) {
    super(props); //目前可行，但有更好的方法
  }


</div></code></pre>
<p>在早期版本中，React.Component 的构造函数参数有两个，第一个是 <code>props</code>，第二个是 <code>context</code>，如果忽略掉 <code>context</code> 参数，那么这个组件的 context 功能就不能正常工作，不过，现在React的行为已经变了，第二个参数传递不传递都能让context正常工作，看起来React.Component 的构造函数只有第一个参数被用到，但是，没准未来还会增加新的参数呢，所以，以不变应万变的方法，就是使用扩展操作符（spread operator）来展开 arguments，这样不管 React 将来怎么变，这样的代码都正确。</p>
<pre class="hljs"><code><div>  constructor() {
    super(...arguments); //永远正确！
  }


</div></code></pre>
<p>扩展操作符的作用，在 React 开发中会经常用到，在 JSX 中展开 props 的时候会用到。</p>
<h2 id="%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">属性初始化方法</h2>
<p>不过，其实我们也可以完全避免编写 constructor 函数，而直接使用属性初始化（Property Initializer），也就是在 class 定义中直接初始化类的成员变量。</p>
<p>不用 constructor，可以这样初始化 state，效果是完全一样的：</p>
<pre class="hljs"><code><div>class StopWatch extends React.Component {
  state = {
    isStarted: false,
    startTime: null,
    currentTime: null,
    splits: [],
  }
}

</div></code></pre>
<p>接下来，我们要考虑如何实现传递给 ControlButtons 的一系列函数。</p>
<p>首先，明确一点，尽量不要在 JSX 中写内联函数（inline function），比如这样写，是很不恰当的：</p>
<pre class="hljs"><code><div>        &lt;ControlButtons
          activated={this.state.isStarted}
          onStart={() =&gt; { /* TODO */}}
          onPause={() =&gt; { /* TODO */}}
          onReset={() =&gt; { /* TODO */}}
          onSplit={() =&gt; { /* TODO */}}
        /&gt;
 

</div></code></pre>
<p>当然，按照上面那种写法，也可以完成程序的功能，但是，会带来性能的代价。首先，每一次渲染这段 JSX，都会产生全新的函数对象，这是一种浪费；其次，因为每一次传给 ControlButtons 的都是新的 props，这样 ControlButtons 也无法通过 <code>shouldComponentUpdate</code> 对 props 的检查来避免重复渲染。</p>
<p>在本小册中后续章节中，为了代码简洁会使用内联函数，但只是为了示例方便，在实际工作中，在 JSX 中应用的函数 props 应该尽量使用类成员函数，不要用内联函数。</p>
<p>以最容易实现的 <code>onSplit</code> 为例，这个函数响应用户点击“计次”按钮的事件，代码如下：</p>
<pre class="hljs"><code><div>  onSplit() {
    this.setState({
      splits: [...this.state.splits, this.state.currentTime - this.state.startTime]
    });
  }

</div></code></pre>
<p>在 onSplit 中，利用 <code>this.setState</code> 来修改组件的状态。不过问题来了，这个函数执行时，<code>this</code> 是什么呢？</p>
<p>很可惜，对于 ES6 的类成员函数，并不自动绑定 <code>this</code>，也就是说，onSplit 中的 <code>this</code>，可不保证就是当前组件对象。</p>
<p>至于 <code>render</code> 这些生命周期函数，里面访问的 <code>this</code> 就是当前组件本身，完全是因为这些函数是 React 调用的，React 对它们进行了特殊处理，对于其他普通的成员函数，特殊处理就要靠我们自己了。</p>
<p>通常的处理方法，就是在构造函数中对函数进行绑定，然后把新产生的函数覆盖原有的函数，就像这样：</p>
<pre class="hljs"><code><div>  constructor() {
    super(...arguments);

    this.onSplit = this.onSplit.bind(this);
  }
 

</div></code></pre>
<p>如果可以使用 bind operator，也可以这样写：</p>
<pre class="hljs"><code><div>    this.onSplit = ::this.onSplit;

</div></code></pre>
<p>只可惜 bind operator 并不是稳定的标准语法，而 create-react-app 又不想依赖不稳定的语法，所以在我们的应用中还不能这么写。</p>
<p>我们的 StopWatch 需要给 ControlButtons 传递四个函数类型的 props，分别是 <code>onStart</code>、<code>onPause</code>、<code>onReset</code> 和 <code>onSplit</code>，对每一个函数都在构造函数里加一个 bind，也是够累的，还容易出错，所以，我们肯定会寻求更好的方法。</p>
<p>更好的方法依然是使用属性初始化，就和初始化 state 一样，利用等号直接初始化 onSplit，代码如下：</p>
<pre class="hljs"><code><div>  onSplit = () =&gt; {
    this.setState({
      splits: [...this.state.splits, this.state.currentTime - this.state.startTime]
    });
  }

</div></code></pre>
<p>像上面这样写，就不需要 constructor，函数体内的 <code>this</code> 绝对就是当前组件对象。</p>
<p>用同样的方法，我们一起实现其他函数成员。</p>
<pre class="hljs"><code><div>  onStart = () =&gt; {
    this.setState({
      isStarted: true,
      startTime: new Date(),
      currentTime: new Date(),
    });

    this.intervalHandle = setInterval(() =&gt; {
      this.setState({currentTime: new Date()});
    }, 1000 / 60);
  }

  onPause = () =&gt; {
    clearInterval(this.intervalHandle);
    this.setState({
      isStarted: false,
    });
  }

  onReset = () =&gt; {
    this.setState({
      startTime: null,
      currentTime: null,
      splits: [],
    });
  }

</div></code></pre>
<p>至此，一个“秒表”的功能就完成了，在 <code>App.js</code> 文件中导入 <code>StopWatch</code>，在浏览器中我们可以看到这样的界面。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/21/165fa7ec74d432ee?w=542&amp;h=270&amp;f=png&amp;s=16387" alt=""></p>
<p>点击“启动”按钮，可以看见数字时钟开始运转；点击“计次”按钮，在按钮下方可以看到点击瞬间的时间；点击“停止”，时钟停止运转。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/21/165fa7f0dcddadd4?w=528&amp;h=618&amp;f=png&amp;s=45828" alt=""></p>
<p>当然，现在这个“秒表”的界面还非常粗糙，和 iPhone 上的秒表应用差远了。但是，它该有的功能一个都不缺，只有功能完整而且正确，样式才有意义。</p>
<p>在后面的章节中，我们会用 React 的方式来来美化界面。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>在这一小节中，我们完成 StopWatch 秒表组件的实现，在这个过程中，读者应该学习到这些技巧：</p>
<ol>
<li>尽量每个组件都有自己专属的源代码文件；</li>
<li>用<strong>解构赋值</strong>（destructuring assignment）的方法获取参数 props 的每个属性值；</li>
<li>利用<strong>属性初始化</strong>（property initializer）来定义 state 和成员函数。</li>
</ol>

</body>
</html>
