<!DOCTYPE html>
<html>
<head>
<title>组件设计模式（4）： 提供者模式.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89%EF%BC%9A%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F">组件设计模式（4）：提供者模式</h1>
<p><strong>资源由 IT视频学习网(www.itspxx.com) 收集并免费发布</strong></p>
<p>这一节我们来介绍 React 中的“提供者模式”（Provider Pattern）。</p>
<h2 id="%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF">问题场景</h2>
<p>在 React 中，props 是组件之间通讯的主要手段，但是，有一种场景单纯靠 props 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/30/16627df7e8c08232?w=1480&amp;h=872&amp;f=png&amp;s=74627" alt="需要提供者的场景"></p>
<p>在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。</p>
<p>其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。</p>
<p>可见，对于跨级的信息传递，我们需要一个更好的方法。</p>
<p>在 React 中，解决这个问题应用的就是“提供者模式”。</p>
<h2 id="%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F">提供者模式</h2>
<p>虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个叫“提供者”（Provider），另一个叫“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者。</p>
<p>既然名为“提供者”，它可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。</p>
<p>避免 props 逐级传递，即是提供者的用途。</p>
<h2 id="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F">如何实现提供者模式</h2>
<p>实现提供者模式，需要 React 的 Context 功能，可以说，提供者模式只不过是让 Context 功能更好用一些而已。</p>
<p>所谓 Context 功能，就是能够创造一个“上下文”，在这个上下文笼罩之下的所有组件都可以访问同样的数据。</p>
<p>在 React v16.3.0 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用，因为对应的 API 他们并不满意，觉得迟早要废弃掉。即使如此，依然有很多库和应用使用 Context 功能，可见对这个需求的呼声有多大。</p>
<p>当 React 发布 v16.3.0 时，终于提供了“正式版本”的 Context 功能 API，和之前的有很大不同，当然，这也带来一些问题，我在后面会介绍。</p>
<p>提供者模式的一个典型用例就是实现“样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。</p>
<p>为了方便比对，这里我会介绍提供者模式用不同 Context API 的实现方法。不过，你如果完全不在意老版本 React 如何实现的，可以略过下面一段。</p>
<h3 id="react-v1630-%E4%B9%8B%E5%89%8D%E7%9A%84%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F">React v16.3.0 之前的提供者模式</h3>
<p>在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做两个特殊处理。</p>
<ol>
<li>需要实现 <code>getChildContext</code> 方法，用于返回“上下文”的数据；</li>
<li>需要定义 <code>childContextTypes</code> 属性，声明“上下文”的结构。</li>
</ol>
<p>下面就是一个实现“提供者”的例子，组件名为 <code>ThemeProvider</code>：</p>
<pre class="hljs"><code><div>class ThemeProvider extends React.Component {
  getChildContext() {
    return {
      theme: this.props.value
    };
  }

  render() {
    return (
      &lt;React.Fragment&gt;
        {this.props.children}
      &lt;/React.Fragment&gt;
    );
  }
}

ThemeProvider.childContextTypes = {
  theme: PropTypes.object
};

</div></code></pre>
<p>在上面的例子中，getChildContext 只是简单返回名为 <code>value</code> 的 props 值，但是，因为 getChildContext 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。</p>
<p>对于 ThemeProvider，我们创造了一个上下文，这个上下文就是一个对象，结构是这样：</p>
<pre class="hljs"><code><div>{
  theme: {
    //一个对象
  }
}

</div></code></pre>
<p>接下来，我们来做两个消费（也就是使用）这个“上下文”的组件，第一个是 <code>Subject</code>，代表标题；第二个是 <code>Paragraph</code>，代表章节。</p>
<p>我们把 Subject 实现为一个类，代码如下：</p>
<pre class="hljs"><code><div>class Subject extends React.Component {
  render() {
    const {mainColor} = this.context.theme;
    return (
      &lt;h1 style={{color: mainColor}}&gt;
        {this.props.children}
      &lt;/h1&gt;
    );
  }
}

Subject.contextTypes = {
  theme: PropTypes.object
}

</div></code></pre>
<p>在 Subject 的 <code>render</code> 函数中，可以通过 <code>this.context</code> 访问到“上下文”数据，因为 ThemeProvider 提供的“上下文”包含 <code>theme</code> 字段，所以可以直接访问 <code>this.context.theme</code>。</p>
<p>千万不要忘了 Subject 必须增加 <code>contextTypes</code> 属性，必须和 ThemeProvider 的 <code>childContextTypes</code> 属性一致，不然，<code>this.context</code> 就不会得到任何值。</p>
<p>读者可能会问了，为什么这么麻烦呢？为什么要求“提供者”用 <code>childContextTypes</code> 定义一次上下文结构，又要求“消费者”再用 <code>contextTypes</code> 再重复定义一次呢？这不是很浪费吗？</p>
<p>React 这么要求，是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。</p>
<p>不过，实话实说，这样的 API 设计的确麻烦了一点，难怪 React 官方在最初就不建议使用。</p>
<p>上面的 Subject 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，我们用纯函数的方式实现另一个消费者 <code>Paragraph</code>，代码如下：</p>
<pre class="hljs"><code><div>const Paragraph = (props, context) =&gt; {
  const {textColor} = context.theme;
  return (
    &lt;p style={{color: textColor}}&gt;
      {props.children}
    &lt;/p&gt;
  );
};

Paragraph.contextTypes = {
  theme: PropTypes.object
};

</div></code></pre>
<p>从上面的代码可以看到，因为 Paragraph 是一个函数形式，所以不可能访问 <code>this.context</code>，但是函数的第二个参数其实就是 <code>context</code>。</p>
<p>当然，也不要忘了设定 Paragraph 的 <code>contextTypes</code>，不然参数 <code>context</code> 也不会是上下文。</p>
<p>最后，我们看如何结合”提供者“和”消费者“。</p>
<p>我们做一个组件来使用 Subject 和 Paragraph，这个组件不需要帮助传递任何 props，代码如下：</p>
<pre class="hljs"><code><div>const Page = () =&gt; (
  &lt;div&gt;
    &lt;Subject&gt;这是标题&lt;/Subject&gt;
    &lt;Paragraph&gt;
      这是正文
    &lt;/Paragraph&gt;
  &lt;/div&gt;
);

</div></code></pre>
<p>上面的组件 <code>Page</code> 使用了 Subject 和 Paragraph，现在我们想要定制样式主题，只需要在 Page 或者任何需要应用这个主题的组件外面包上 ThemeProvider，对应的 JSX 代码如下：</p>
<pre class="hljs"><code><div>  &lt;ThemeProvider value={{mainColor: 'green', textColor: 'red'}} &gt;
    &lt;Page /&gt;
  &lt;/ThemeProvider&gt;


</div></code></pre>
<p>最后，看到的效果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/1/166cf8369b95d131?w=950&amp;h=224&amp;f=png&amp;s=18848" alt="Theme Provider"></p>
<p>当我们需要改变一个样式主题的时候，改变传给 ThemeProvider的 value 值就搞定了。</p>
<h3 id="react-v1630-%E4%B9%8B%E5%90%8E%E7%9A%84%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F">React v16.3.0 之后的提供者模式</h3>
<p>到了 React v16.3.0 的时候，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。</p>
<p>还是上面的样式主题的例子，首先，要用新提供的 <code>createContext</code> 函数创造一个“上下文”对象。</p>
<pre class="hljs"><code><div>const ThemeContext = React.createContext();

</div></code></pre>
<p>这个“上下文”对象 <code>ThemeContext</code> 有两个属性，分别就是——对，你没猜错——<code>Provider</code> 和 <code>Consumer</code>。</p>
<pre class="hljs"><code><div>const ThemeProvider = ThemeContext.Provider;
const ThemeConsumer = ThemeContext.Consumer;

</div></code></pre>
<p>创造“提供者”极大简化了，都不需要我们创造一个 React 组件类。</p>
<p>使用“消费者”也同样简单，而且应用了上一节我们介绍的 render props 模式，比如，Subject 的代码如下:</p>
<pre class="hljs"><code><div>class Subject extends React.Component {
  render() {
    return (
      &lt;ThemeConsumer&gt;
        {
          (theme) =&gt; (
            &lt;h1 style={{color: theme.mainColor}}&gt;
              {this.props.children}
            &lt;/h1&gt;
          )
        }
      &lt;/ThemeConsumer&gt;
    );
  }
}

</div></code></pre>
<p>上面的 <code>ThemeConsumer</code> 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。</p>
<p>在新的 API 里，不需要设定组件的 <code>childContextTypes</code> 或者 <code>contextTypes</code> 属性，这省了不少事。</p>
<p>可以注意到，Subject 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 <code>Paragraph</code>，代码如下：</p>
<pre class="hljs"><code><div>const Paragraph = (props, context) =&gt; {
  return (
    &lt;ThemeConsumer&gt;
      {
        (theme) =&gt; (
          &lt;p style={{color: theme.textColor}}&gt;
            {props.children}
          &lt;/p&gt;
          )
      }
    &lt;/ThemeConsumer&gt;
  );
};

</div></code></pre>
<p>实现 <code>Page</code> 的方式并没有变化，而应用 <code>ThemeProvider</code> 的代码和之前也完全一样:</p>
<pre class="hljs"><code><div>  &lt;ThemeProvider value={{mainColor: 'green', textColor: 'red'}} &gt;
    &lt;Page /&gt;
  &lt;/ThemeProvider&gt;

</div></code></pre>
<h2 id="%E4%B8%A4%E7%A7%8D%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">两种提供者模式实现方式的比较</h2>
<p>通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但是，也并不是十全十美。</p>
<p>在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。</p>
<p>在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 <code>ThemeContext</code>)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，那么，这个 <code>ThemeContext</code> 对象放在哪个代码文件中呢？</p>
<p>最好是放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。</p>
<p>为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。</p>
<p>不管怎么说，新版本的 Context API 才是未来，在 React v17 中，可能就会删除对老版 Context API 的支持，所以，现在大家都应该使用第二种实现方式。</p>
<h1 id="%E5%B0%8F%E7%BB%93">小结</h1>
<p>这一小节我们介绍了“提供者模式”，读者应该能够理解：</p>
<ol>
<li>提供者模式解决的问题；</li>
<li>React 的 Context 功能对这种模式有很直接的支持；</li>
<li>提供者模式中 render props 的应用。</li>
</ol>
<p>在接下来关于 Redux 和 Mobx 的介绍中，可以看到“提供者模式”更广泛的应用。</p>

</body>
</html>
