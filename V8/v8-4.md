###前言
JavaScript作为快捷入门编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，前端也不再是页面仔的简单验证，Flutter的兴起促进了大前端不断深入原生开发者（Android、ios）的领域。回首前端，JS这门解释执行的动态脚本语言，不光成为前端届的“正统”，还入侵了后端开发领域，在编程语言排行榜上进入前三甲，仅次于Python和Java。而如何解释执行JS，则是各家引擎的核心技术。目前市面上比较常见的JS引擎有 Google 的 V8（它被运用在Android操作系统以及Google的Chrome上），以及JSCore（它被运用在iOS操作系统以及Safari上）。
今天的内容是，复习浏览器的运行过程。

###浏览器工作流程
实际上，对浏览器的实现者来说，他们做的事情，就是把一个URL变成一个屏幕上显示的网页。
这个过程是这样的：
1. 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；
2. 把请求回来的 HTML 代码经过解析，构建成 DOM 树；
3. 计算 DOM 树上的 CSS 属性；
4. 最后根据 CSS 属性对元素逐个进?渲染，得到内存中的位图；
5. 一个可选的步骤是对位图进?合成，这会极大地增加后续绘制的速度；
6. 合成之后，再绘制到界面上。

#####HTTP协议
浏览器首先要做的事就是根据URL把数据取回来，取回数据使用的是HTTP协议（实际上这个过程之前还有DNS查询，不过这
方面就不详细展开了。）HTTP协议是基于TCP协议出现的，对TCP协议来说，TCP协议是一条双向的通讯通道，HTTP在TCP的基础上，规定了Request-Response的模式。这个模式决定了通讯必定是由浏览器端首先发起的。?部分情况下，浏览器的实现者只需要一个个TCP库，甚??个现成的HTTP库就可以搞定浏览器的网络通讯部分。HTTP是纯粹的文本协议，它是规定了使用TCP协议来传输文本格式的一个应用层协议。
下面，我们试着用一个纯粹的TCP客户端来模拟实现HTTP：
```
// 实验
// 需要使用telnet客户端，这个客户端是一个纯粹的TCP连接工具（安装方法）。
// 首先我们运行telnet，连接到主机，在命令行输入以下内容：
telnet limeini.com 80
// www.limeini.com 是我的个人网站域名,

// 这个时候，TCP连接已经建?，我们输入以下字符作为请求：
GET / HTTP/1.1
Host: limeini.com

// 按下两次回车，我们收到了服务端的回复：
HTTP/1.1 301 Moved Permanently
Date: Fri, 25 Jan 2019 13:28:12 GMT
Content-Type: text/html
Content-Length: 182
Connection: keep-alive
Location: https://time.geekbang.org/
Strict-Transport-Security: max-age=15768000
<html>
<head><title>301 Moved Permanently</title></head>
<body bgcolor="white">
<center><h1>301 Moved Permanently</h1></center>
<hr><center>openresty</center>
</body>
</html>
```
这就是一次完整的HTTP请求的过程了，我们可以看到，在TCP通道中传输的，完全是文本。在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。
在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。紧随在request line或者response line之后，是请求头/响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。
在头之后，以一个空行（两个换行符）为分隔，是请求体/响应体，请求体可能包含文件或者表单数据，响应体则是html代码。

#####HTTP协议格式
根据上面的分析，我们可以知道HTTP协议，大概可以划分成如下部分。
// 图
我们简单看一下，在这些部分中，path是请求的路径完全由服务端来定义，没有很多的特别内容；而version几乎都是固定字
符串；response body是我们最熟悉的HTML。

#####HTTP Method
我们首先来介绍一下request line里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次HTTP请求希望执
行的操作类型。方法有以下几种定义：
- GET
- POST
- HEAD
- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE

浏览器通过地址栏访问页面都是GET?法。表单提交产生POST方法。
HEAD则是跟GET类似，只返回请求头，多数由JavaScript发起
PUT和DELETE分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。
CONNECT现在多用于HTTPS和WebSocket。
OPTIONS和TRACE一般用于调试，多数线上服务都不支持。

#####Status code
接下来我们看看response line的状态码和状态文本。常见的状态码有以下几种。
- 1xx：临时回应，表示客户端请继续。
- 2xx：请求成功。
- 200：请求成功。
- 3xx: 表示请求的?标有变化，希望客户端进一步处理。
- 301&302：永久性与临时性跳转。
- 304：跟客户端缓存没有更新。
- 4xx：客户端请求错误。
- 403：无权限。
- 404：表示请求的页面不存在。
- 418：It’s a teapot. 这是一个彩蛋（超文本咖啡壶控制协议）
- 5xx：服务端请求错误。
- 500：服务端错误。
- 503：服务端暂时性错误，可以?会再试。

对我们前端来说，1xx系列的状态码是非常陌生的，原因是1xx的状态被浏览器http库直接处理掉了，不会让上层应用知晓。
2xx系列的状态最熟悉的就是200，这通常是网页请求成功的标志，也是?家最喜欢的状态码。
3xx系列比较复杂，301和302两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上301
更接近于一种报错，提示客户端下次别来了。
304又是一个每个前端必知必会的状态，产?这个状态的前提是：客户端本地已经有缓存的版本，并且在Request中告诉了服
务端，当服务端通过时间或者tag，发现没有更新的时候，就会返回一个不含body的304状态。

#####HTTP Head
HTTP头可以看作一个键值对。原则上，HTTP头也是一种数据，我们可以自由定义HTTP头和值。不过在HTTP规范中，规定
了一些特殊的HTTP头，我们现在就来了解一下它们。
在HTTP标准中，有完整的请求/响应头规定，这里我们挑几个重点的复习一下：
我们先来看看Request Header。
// 图1
接下来看一下Response Header
// 图2
这里仅仅列出了比较常见的HTTP头，完整的列表还需要具体参考RFC2616标准。

#####HTTP Request Body
HTTP请求的body主要用于提交表单场景。实际上，http请求的body是比较自由的，只要浏览器端发送的body服务端认可就可
以了。一些常件的body格式是：
- application/json
- application/x-www-form-urlencoded
- multipart/form-data
- text/xml

我们使用html的form标签提交产生的html请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用multipart/form-data。

######HTTPS
在HTTP协议的基础上，HTTPS和HTTP2规定了更复杂的内容，但是它基本保持了HTTP的设计思想，即：使用上RequestResponse模式。我们首先来了解下HTTPS。HTTPS有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。
HTTPS是使用加密通道来传输HTTP的内容。但是HTTPS首先与服务端建立一条TLS加密通道。TLS构建于TCP协议之上，它
实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS跟HTTP没有任何区别。

######HTTP2
HTTP2.0 最大的改进有两点，一是支持服务端推送、二是支持TCP连接复用（也称多路复用）。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放在缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。
TCP连接复用，则使用同一个TCP连接来传输多个HTTP请求，在实际工作中可以把 CSS 和 JS 文件分拆成更小的文件，分批下载。避免了TCP连接建立时的三次握手开销，和初建TCP连接时传输窗口小的问题。

###DOM树的构建
浏览器使用HTTP协议或者HTTPS协议，向服务端请求页面的过程后，如何解析请求回来的HTML代码，DOM树又是如何构建的。

#####解析代码
我们在前?讲到了HTTP的构成，但是我们有?部分没有详细讲解，那就是Response的body部分，这正是因为HTTP的Response的body，就要交给我们今天学习的内容去处理了。
HTML的结构不算太复杂，我们平常开发需要的90%的“词”（指编译原理的术语token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA节点几种。实际上有点麻烦的是，由于HTML跟SGML的千丝万缕的联系，我们需要做不少容错处理。“<?”和“<%”什么的也是必须支持
好的，报了错也不能吭声。
首先我们来看看一个非常标准的标签，会被如何拆分：```
<p class="a">text text text</p>
```
如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个p标签肯定是过大了（它甚至可以嵌套）。那么，只有p标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“<p” ，所以“ <p” 就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）：- <p“标签开始”的开始；
- class=“a” 属性；
- > “标签开始”的结束；
- text text text ?本；
- </p>标签结束。
这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样?：
// tu




#####状态机



#####构建DOM树


