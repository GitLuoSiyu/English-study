1. display:none 和 visibility:hidden 的区别？
display:none 是彻底的消失 不占文档流 浏览器不会解析  会产生回流
visibility:hidden 是视觉上的消失 占文档流 浏览器会解析	不会产生回流(重绘)

2. jq中找到所有与元素的同级元素需要用到: $('.box').sibilings()

3. 懒加载: 
原理:现将img标签中的src链接设置为同一张空白图片，将其真正的图片地址存储在自定义属性中(data-src)
	JS监听该图片元素进入到可视区域时,将其自定义属性中的值存储到src属性中，达到懒加载的效果
好处:防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿等问题

4. 状态管理:
概念:它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式管理。

5. 什么时候使用vuex?
开发大型单页应用(Flux 架构就像眼镜：您自会知道什么时候需要它)

6. 浏览器缓存:
强缓存
协商缓存

7. promise模拟计时器？
```javaScript

let start = new Date();
console.log(`start: ${start}`);
setTimeout(()=>{
console.log('This line will be log in 3 seconds?');
console.log(`end  : ${new Date()}`);
}
, 3000);

while (true) {

if ((+start + 5000) < +new Date()) {
	return;
}
}

```

8. promise回调并发?
回调并发:又叫回调地狱,异步调用一般分为两个阶段,提交请求和处理结果,这两个阶段之间有时间循环的调用,它们属于两个不同的事件循环,彼此没有关联
	异步调用一般以传入callback的方式来指定异步操作完成后要执行的动作。而异步调用的本体和callback属于不同的时间循环
处理方法: try...catch语句只能捕获当前事件循环的异常,对callback无能为力
	 也就是说,一旦我们在异步调用函数中扔出一个I/O请求,异步调用函数立即返回,此时,这个异步调用的函数和这个异步I/O请求没有任何关系
	 
9. Ajax处理前后台交互?
```javaScript

		function ajax(options){
			//-1  整理options
			options=options||{};
			options.data=options.data||{};
			options.timeout=options.timeout||0;
			options.type=options.type||'get';
			
			//0 整理data
			var arr=[];
			for(var key in options.data){
				arr.push(key+'='+encodeURIComponent(options.data[key]));	
			}
			var str=arr.join('&');
			
			//1	创建ajax对象
			if(window.XMLHttpRequest){
				var oAjax=new XMLHttpRequest();//[object XMLHttpRequest]
			}else{
				var oAjax=new ActiveXObject('Microsoft.XMLHTTP')
			}
			
			if(options.type=='get'){
				//2.
				oAjax.open('get',options.url+'?'+str,true);
				//3.
				oAjax.send();
			}else{
				//2.
				oAjax.open('post',options.url,true);
				//设置请求头
				oAjax.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
				oAjax.send(str);//身子
			}
			
			//3.5	超时
			if(options.timeout){
				var timer=setTimeout(function(){
					alert('超时了');
					oAjax.abort();//中断ajax请求	
				},options.timeout);
			}
			
			
			//4.
			oAjax.onreadystatechange=function(){//当准备状态改变时
				if(oAjax.readyState==4){//成功失败都会有4
					clearTimeout(timer);
					if(oAjax.status>=200 && oAjax.status<300 || oAjax.status==304){
						options.success && options.success(JSON.parse(oAjax.responseText));
					}else{
						options.error && options.error(oAjax.status);//http	0
					}
				}
			};
			
			
		};

```

10. H5的新增标签? css3的新特性?
H5:	<header>	<section>	<article>	<aside>	<mask>	<canvas>	<footer>	<nav>
css3: 	border-shadow	border-image border-radius
	background-size	background-origin(规定背景图片定位区域)
	text-shadow
	transform:translate()/rotate()

11. 闭包
定义:闭包就是能够读取其他函数内部变量的函数,也可以说是一个定义在一个函数内部的函数
本质:链接函数内部与函数外部的桥梁
缺点:1.会使函数内部的变量保存在内存中,内存消耗很大,所以不能滥用
	 2.闭包会在父函数的外部,改变父函数内部变量的值

12. 跨域问题？
含义:同协议,同域名,同端口,有一个不满足都存在跨域问题
解决办法:Jsonp Ajax CORS Nginx反向代理 后台用SpringMVC

13. ES6的新特性?
引入了块级作用域		{}
const命令			用来定义常量
解构赋值				let [a,b,c] = [1,2,3]
箭头函数				()=>{}
数组的扩展			[...arr1]
Symbol函数			具有唯一性
set/map遍历
Promise---异步
class类

14. 箭头函数与普通函数this的指向问题?	
普通函数：this总是代表它的直接调用者	obj.fun ---> obj
		 在默认情况下，没有直接调用者, 指向window
		 在严格模式下,没有直接调用者,指向undefine
		 使用call,apply,bind,this指向绑定的对象
箭头函数: 默认指向定义它时,它所处的对象,而不是执行时的对象	定义它的时候，可能环境处于window(即继承父级的this)

15. vuex的双向绑定原理?
采用了数据劫持结合发布者-订阅者模式的方式,通过Object.defineProperty()来劫持各个属性是setter,getter,在数据变动时发布消息给订阅者并触发相应的监听回调

16. 在网页中会引用那些常见的静态资源?
JS
	.js .jsx .coffee .ts
CSS
	.css .scss .less  .stylus
Image
	.jpg .png .gif .bmp .svg .ttf  .webp
字体文件
	.svg .btf .eot .woff .woff2
模板文件
	.ejs .jade .vue(webpack定义组件的方式)

17. 过多的静态资源对页面有什么影响?
问题：页面加载速度过慢, 因为我们会多次发送二次请求
	 要处理错综复杂的依赖关系
解决方法：合并 压缩 精灵图 图片base64编码	使用webpack

18. 节点绑定失效: 那就在事件绑定之前,给该节点的父节点绑定事件

19.生命周期函数: 
Vue:	初始化: beforeCreate		created(获取数据)		beforeMount		Mounted(获取节点)		
		进行中: beforeUpdata		upDated
		销 毁:  beforeDistory 	Distoryed
		
React:	初始化: getDefaultProps	getInitialState		componentWillMount(获取数据)		render(渲染虚拟DOM)		componentDidMount
		进行中: componentWillReceiveProps	shouldComponentUpdate	componentWillUpdate		render		componentDidUpdate
		卸  载:	componentWillUnmount
		
20. 前端性能的优化:
	减少http请求的次数
	将样式表放在顶部
	将脚本放在底部
	避免css表达式
	使用外部Js以及css
	减少DNS查找
	精简js
	使ajax可缓存

21. 本地对象、内置对象、宿主对象?
	本地对象: arrary object 等可以new实例化的
	内置对象: gload math 等不可以实例化的
	宿主对象: window document 等浏览器自带的

22. vue组件之间的信息传递?
	父 ---> 子: 父向子传递数据是通过props	父组件绑定属性，子组件props接收
	子 ---> 父: 通过绑定方法$emit和$on  	父组件向子组件传递方法,子组件用$emit接收可以直接调用
	同级之间的传递: 1.使用一个空的vue实例作为中央事件总线
								 2. 使用vuex

23. vue修改data数据并且实时显示?
	1. 首先定义一个变量
	2. 给变量赋值
	实时显示: 利用vue.set(data,"改变的属性名",属性值val)
```javaScript

var acticleVal = null;

articleVal = new Vue({
	el:'app',
	data:{
		article:msg
	}
})

var datas = [{id:1,book:"活着"},{id:2,book:'小王子'}]
articleVal.$data.article = datas

<div v-for = 'v in article' :key='v.id'>{v.book}</div>

```

24. eval():主要是计算js字符串,并把它作为脚本来执行

25. node.js的使用场景?
	RESTFUL API  实时聊天	以及客户端逻辑强大的单页app

26.	call()和apply()的区别?
	call:可以接受多个参数,第一个参数是this,后面则是一串参数列表
	apply: 最多只能接受两个参数, 第一个是this,第二个是数组,所以传多个参数的话要放在数组里
	因此 : apply和call的功能是一样的,只是传入参数的形式不一样

27. ajax是什么? ajax的交互模型? 同异步的区别? ajax解决跨域?
	ajax:是异步的js和xml。通过在后台与服务器进行少量数据交换,ajax可以使页面实现异步更新。意味着可以不重新加载整个页面,而对页面 某部分进行更新
	交互流程: 获取XMLHttpRequest对象---> open 开启url通道,设置异步传输 
						---> send 发送数据 ---> 服务端接收数据并处理并返回结果 ---> 客户端接收返回数据
	同步: 脚本会停留并且等待服务器发送恢复然后在继续
	异步: 脚本允许页面继续其进程并处理可能的回复
	ajax解决跨域: 1. web代理 A网站与B网站需建立紧密协作的关系，A网站服务器负担会增加  并且无法带用户保存session状态
							 2. on - Demand方式 通过动态修改script属性完成对跨域页面的调用 
							 3. iframe方式
							 4. 用户本地存储方式
					
28. 改变浏览器地址，但不发送请求的两种方式:
	1.在地址中加#，用来欺骗浏览器	地址的改变值由于正在进行页内导航
	2.使用h5中window.history功能,使用url的hash来模拟完整的url

29. 虚拟Dom?
	用js对象的形式来模拟页面上DOM嵌套关系(以js对象的形式存在的)
	本质: 用Js对象，来模拟DOM元素和嵌套关系
	目的: 为了实现页面中，DOM元素的高效更新
	
30. DOM和虚拟DOM的区别?
	DOM: 浏览器中,提供的概念,用JS对象,表示页面上的元素,并提供了操作元素的API
	虚拟DOM:是框架中的概念,是开发框架的程序员,手动用JS对象模拟DOM元素和嵌套关系

31. MVC与MVVM区别?
	MVC: 允许在不改变视图的情况下改变视图对用户输入的响应式
			 用户View操作交给了Controller处理,在Controller中响应View的事件调用Model的接口对数据进行操作,一旦model变化相关视图也会跟着更新
	MVVM:是"数据模型数据双向绑定"的思想为核心,所以view和model之间没有联系，通过ViewModel进行交互
	区别: mvvm 与mvc 最大的区别是它实现了view和model的自动同步,也就是当model的属性改变时,我们不用再自己手动操作dom元素,
				来改变view的显示,而是改变属性后该属性对应的View层显示也会跟着变化

32. vue的理解?
	Vue.js 不是一个框架 它只聚焦视图层,是一个构建数据驱动的Web界面库
	优点: 1. 轻量 体积小,不依赖其他的基础库
			2. 数据绑定
			3. 指令	类似angular,可以用一些内置的简单指令
			4. 插件化	不包括Router,ajax表单验证,但可方便的加载对应插件
	  
33. 框架间的对比?
	生命周期
	渲染机制: vue 用的是基于html语法的模板	允许开发者声明式的将Dom绑定到vue的底层实例上	
								核心: Vue.js是一个允许你采用简洁的模板语法来声明式的将数据渲染进Dom系统里
					 react 是将html语法直接写在Js语法中, 不加任何引导, 这就是JSX语法 允许Html与Js混写
	状态管理机制: vue 是用vuex来进行状态管理的
							 react redux   react-redux redux-thunk prop-types
											 
34. 双向数据绑定?
	基于ES5中的defineProperty来实现的,支持IE9

35. 双向数据流?
	js内存属性发生改变,影响页面变化
	页面的改变影响js内存属性的改变

36. react的理解?
	react的三个关键字:
		1. just the ui		负责ui层面的表现,它把ui拆分成组件,并且引入了Jsx语法,使它更容易拓展和维护 
		2. virtual dom		减少真实dom的操作,提高了性能
		3. data flow			react的数据流是从组件树从上到下单向流动
		4. redux

37. 作用域链?
	作用域: 变量所使用的范围称为作用域
					全局作用域: 定义在函数外的变量会被保存在全局作用域中，且能够能够被其他作用域访问和修改
					局部作用域: 声明在函数内, 且变量之间彼此不能访问
	作用域链: 用于解析变量, 当解析一个变量的时候js开始从最内层沿着父级寻找所需的变量或其他资源
						包含自己执行环境以及所有父级环境中包含的变量

38. json数据格式?
	是前端数据交互的常用格式，一般是数组格式和对象格式
	json.parse(转json) 			json.stringify(转成字符串)
	eval('('+ data +')')(转成json)
	
39. 动态创建元素绑定不上事件?
	dom没有跟着渲染出来
	
40. vuex解决跨域?
	跨域代理表	proxy 
	1. 找到config文件夹下的index.js配置proxyTable
```javaScript

	proxyTable:{
		'/api':{
			target:'http://api.xxxxxxxxxx.com',
			changeOrigin:true,
			pathRewrite:{
				'^/api':'/api'
			}
		}
	}
// 说明配置中target后面的内容为后端人员提供的数据接口
// 原理类似vpn做了一个中转，Node替你去接口请求数据
```
	2. 调用
```javaScript

this.$http.get('/api/login.json').then((data)=>{
console.log(data)
})

```

41. 事件委托?
	把子元素上的事件放在父元素身上称为事件委托
	利用事件冒泡原理
	
42. 数组的常用方法?
	indexOf() 返回数组中可以找到一个给定元素的第一个索引,如果不存在,则返回-1
	join()		将数组中的所有元素连接到一个字符串中
	map()			创建一个新数组,其结果是该数组中的每个元素都调用了一个提供的函数的后返回的结果
						指"映射",对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组						
	forEach() 对数组进行遍历循环,对数组中的每一项运行给定函数,这个方法没有返回值。
						参数都是function类型,默认有传参,参数分别为:遍历的数组内容;第对应的数组索引,数组本身
	reduce()  累加器
	some()		测试数组中的某些元素是否通过由提供的函数实现的测试
	sort()		当地位置对数组元素进行排序,并返回数组
	slice()		返回一个从开始到结束(不包括结束)选择的数组的一部分浅拷贝到一个新的数组中
	spice()		可以实现删除插入替换		1.删除任意数量的项,只需指定 2 个参数:要删除的第一项的位置和要删除的项数。
																		例如,splice(0,2)会删除数组中的前两项
																	2.可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。
																		例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。
																	3.可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
																		例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6
43. 字符串常用的方法?
	str.substring(start,end)  两个参数都为正数,返回值:[start,end) 也就是说返回从start到end-1的字符
　　	str.slice(start,end)		  两个参数可正可负,负值代表从右截取,返回值:[start,end) 也就是说返回从start到end-1的字符
	str.split(separator,limit)参数1指定字符串或正则，参照2指定数组的最大长度
	str.replace(rgExp/substr,replaceText)   返回替换后的字符串









```javaScript
Explem:
1.懒加载
https://github.com/jirengu-inc/jrg-renwu10/blob/master/homework/%E5%AD%99%E7%BA%A2%E7%85%A7/mission29/demo2.html

2. 无限加载
https://github.com/jirengu-inc/jrg-renwu10/blob/master/homework/%E5%AD%99%E7%BA%A2%E7%85%A7/mission29/demo3.html

3. 置顶
https://github.com/jirengu-inc/jrg-renwu10/blob/master/homework/%E5%AD%99%E7%BA%A2%E7%85%A7/mission29/demo1.html

```

