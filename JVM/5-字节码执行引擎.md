本篇将从概念模型的角度来介绍虚拟机的方法调用和字节码执行。

概述
运行时栈帧结构
方法调用


1.概述
a.有关虚拟机与物理机的异同

同：都有代码执行能力
异：

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的
虚拟机的执行引擎是由自定义的，可自行制定指令集与执行引擎的结构体系，且能够执行不被硬件直接支持的指令集格式



b.有关Java虚拟机字节码执行引擎的概念模型

从外观上，所有Java虚拟机的执行引擎都是一致的。输入的是字节码文件，处理的是字节码解析的等效过程，输出的是执行结果
从实现上，执行引擎有多种执行Java代码的选择

解释执行：通过解释器执行
编译执行：通过即时编译器产生本地代码执行
两者兼备，甚至还会包含几个不同级别的编译器执行引擎




2.运行时栈帧结构



栈帧（Stack Frame）：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素
存储内容：方法的局部变量表、操作数栈、动态连接、方法返回地址一些额外的附加信息
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
一个栈帧需要分配多少内存在程序编译期就已确定，而不会受到程序运行期变量数据的影响
对于执行引擎来说，只有位于栈顶的栈帧（当前栈帧）才是有效的，即所有字节码指令只对当前栈帧进行操作，与当前栈帧相关联的方法称为当前方法




在概念模型上，典型的栈帧结构如图：









接下来详细介绍栈帧中各个部分的作用和数据结构
a.局部变量表

局部变量表（Local Variable Table）是一组变量值存储空间
作用：存放方法参数和方法内部定义的局部变量
分配时期：Java程序编译为Class文件时，会在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
最小单位：变量槽

大小：虚拟机规范中没有明确指明一个变量槽占用的内存空间大小，允许变量槽长度随着处理器、操作系统或虚拟机的不同而发生变化

对于32位以内的数据类型（boolean、byte、char、short、int、float、reference、returnAddress ），虚拟机会为其分配一个变量槽空间
对于64位的数据类型（long、double ），虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间


特点：可重用。为了尽可能节省栈帧空间，若当前字节码PC计数器的值已超出了某个变量的作用域，则该变量对应的变量槽可交给其他变量使用


访问方式：通过索引定位。索引值的范围是从0开始至局部变量表最大的变量槽数量

b.操作数栈

操作数栈（Operand Stack）是一个后入先出栈
作用：在方法执行过程中，写入（进栈）和提取（出栈）各种字节码指令
分配时期：同样的，在编译时会在方法的Code属性的max_locals数据项中确定操作数栈的最大深度


在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值


栈容量：操作数栈的每一个元素可以是任意的Java数据类型——32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2
注意：操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译时编译器需要验证一次、在类校验阶段的数据流分析中还要再次验证

c.动态连接（Dynamic  Linking）：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接

静态解析和动态连接：Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用：

一部分会在类加载阶段或者第一次使用的时候就转化为直接引用（静态解析）
另一部分会在每一次运行期间转化为直接引用（动态连接）


d.方法返回地址

方法退出的两种方式：


正常完成出口（Normal Method Invocation Completion）：执行中遇到任意一个方法返回的字节码指令；可能会给上层调用者传递返回值

异常完成出口（Abrupt Method Invocation Completion）：执行中遇到异常、且在本方法的异常表中没有搜索到匹配的异常处理器区处理；不会给上层调用者传递返回值


作用：无论哪种退出方式，在方法返回时都可能在栈帧中保存一些信息，用于恢复上层方法调用者的执行状态

正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值
异常退出时，通过异常处理器表来确定返回地址，栈帧中一般不会保存这部分信息


方法退出的执行操作：恢复上层方法的局部变量表和操作数栈、若有返回值把它压入调用者栈帧的操作数栈中、调整PC计数器的值以指向方法调用指令后面的一条指令等

e.附加信息：增加一些规范里没有描述的信息到栈帧之中，如与调试相关的信息

在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部一起称为栈帧信息


3.方法调用

方法调用是最普遍、最频繁的操作（方法调用≠方法执行）
任务：确定被调用方法的版本，即调用哪一个方法，不涉及方法内部的具体运行过程
类型：


解析（Resolution）调用：

特点：是静态过程；在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，而不会延迟到运行期再去完成，即编译期可知、运行期不可变

适用对象：静态方法（与类型直接关联）、私有方法（在外部不可被访问），它们都不可能通过继承或其他方式重写其他版本



分派（Dispatch）调用：

特点：可静可动
类型：


静态分派：依赖静态类型来定位方法的执行版本；典型应用是方法重载；发生在编译阶段，不由Java虚拟机来执行

动态分派：依赖动态类型来定位方法的执行版本；典型应用是方法重写；发生在运行阶段，由Java虚拟机来执行

单分派：根据一个宗量对目标方法进行选择（方法的接受者与方法的参数统称为方法的宗量）

多分派：根据多于一个宗量对目标方法进行选择







如何理解Java语言是一门静态多分派、动态单分派的语言？

