本篇将介绍虚拟机如何实现多线程、多线程之间由于共享和竞争数据而导致的一系列问题及解决方案。

概述
Java内存模型
Java与线程


1.概述
a.多任务处理的必要性：

充分利用计算机处理器的能力，避免处理器在磁盘I/O、网络通信或数据库访问时总是处于等待其他资源的状态。
便于一个服务端同时对多个客户端提供服务。通过指标TPS（Transactions Per Second）可衡量一个服务性能的高低好坏，它表示每秒服务端平均能响应的请求总数，进而体现出程序的并发能力。

b.硬件的效率与一致性

为了更好的理解Java内存模型，先理解物理计算机中的并发问题，两者有很高的可比性。

为了平衡计算机的存储设备与处理器的运算速度之间几个数量级的差距，引入一层高速缓存（Cache）来作为内存与处理器之间的缓冲：

将运算需要使用到的数据复制到缓存中，让运算能快速进行；
当运算结束后再从缓存同步回内存之中，而无须让处理器等待缓慢的内存读写。

但是基于高速缓存的存储交互在多处理器系统中会带来缓存一致性（Cache Coherence）的问题。这是因为每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），当多个处理器的运算任务都涉及同一块主内存区域时，就可能导致各自的缓存数据不一致。解决办法就是需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。如下图。







因此，这里所说的内存模型可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

2.Java内存模型（Java  Memory  Model，JMM）
a.目的：屏蔽掉各种硬件和操作系统的内存访问差异，实现Java程序在各种平台下都能达到一致的内存访问效果。
b.方法：通过定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

注意：这里的变量与Java中说的变量不同，而指的是实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

c.结构：模型结构如图，和上张图进行类比。









主内存（Main Memory）：所有变量的存储位置。直接对应于物理硬件的内存。


注意：这里的主内存、工作内存与要点提炼| 理解JVM之内存管理说的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分。



工作内存（Working Memory）：每条线程还有自己的工作内存，用于保存被该线程使用到的变量的主内存副本拷贝。为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。


注意：

线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。




交互协议：用于规定一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节。共有8种操作：

①用于主内存变量：

锁定（lock）：把变量标识为一条线程独占的状态。

解锁（unlock）：把处于锁定状态的变量释放出来。

读取（read）：把变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。

载入（load）：把read操作从主内存中得到的变量值放入工作内存的变量副本中。
②用于工作内存变量：

使用（use）：把工作内存中一个变量的值传递给执行引擎。

赋值（assign）：把从执行引擎接收到的值赋给工作内存的变量。

存储（store）：把工作内存中变量的值传送到主内存中，以便随后的write操作使用。

写入（write）：把store操作从工作内存中得到的变量的值放入主内存的变量中。




结论：注意是顺序非连续

如果要把变量从主内存复制到工作内存，那就要顺序地执行read和load。
如果要把变量从工作内存同步回主内存，就要顺序地执行store和write。


d.确保并发操作安全的原则：
①在Java内存模型中规定了执行上述8种基本操作时需要满足如下规则：

不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
不允许一个线程无原因地，即没有发生过任何assign操作就把数据从线程的工作内存同步回主内存中。
一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即对一个变量实施use、store操作之前必须先执行过了assign和load操作。
一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。


可见这么多规则非常繁琐，实践也麻烦，下面再介绍一个等效判断原则--先行发生原则。

②先行发生原则：是Java内存模型中定义的两项操作之间的偏序关系。下面例举一些“天然的”先行发生关系，无须任何同步器协助就已经存在，可以在编码中直接使用。


程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。

管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。

volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。

线程启动规则（Thread Start Rule）：Thread对象的start()先行发生于此线程的每一个动作。

线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测.可通过Thread.join()结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。

线程中断规则（Thread Interruption Rule）：对线程interrupt()的调用先行发生于被中断线程的代码检测到中断事件的发生。可通过Thread.interrupted()检测到是否有中断发生。

对象终结规则（Finalizer Rule）：一个对象的初始化完成先行发生于它的finalize()的开始。

传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A一定先行发生于操作C。

e.Java内存模型保证并发过程的原子性、可见性和有序性的措施：


原子性（Atomicity）：一个操作要么都执行要么都不执行。

可直接保证的原子性变量操作有：read、load、assign、use、store和write，因此可认为基本数据类型的访问读写是具备原子性的。
若需要保证更大范围的原子性，可通过更高层次的字节码指令monitorenter和monitorexit来隐式地使用lock和unlock这两个操作，反映到Java代码中就是同步代码块synchronized关键字。



可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。

通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现。
提供三个关键字保证可见性：volatile能保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；synchronized对一个变量执行unlock操作之前可以先把此变量同步回主内存中；被final修饰的字段在构造器中一旦初始化完成且构造器没有把this的引用传递出去，就可以在其他线程中就能看见final字段的值。



有序性（Ordering）：程序代码按照指令顺序执行。

如果在本线程内观察，所有的操作都是有序的，指“线程内表现为串行的语义”；如果在一个线程中观察另一个线程，所有的操作都是无序的，指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
提供两个关键字保证有序性：volatile 本身就包含了禁止指令重排序的语义；synchronized保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入。




3.Java与线程
a.线程实现的三种方式
①使用内核线程（Kernel-Level Thread,KLT）


定义：直接由操作系统内核支持的线程。

原理：由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身， 这样操作系统就有能力同时处理多件事情。

多线程内核（Multi-Threads Kernel）：支持多线程的内核

轻量级进程（Light Weight Process,LWP）：内核线程的一种高级接口


优点：每个轻量级进程都由一个内核线程支持，因此每个都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞，也不会影响整个进程继续工作。

缺点：由于基于内核线程实现，所以各种线程操作（创建、析构及同步）都需要进行系统调用，代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换；另外，一个系统支持轻量级进程的数量是有限的。

一对一线程模型：轻量级进程与内核线程之间1：1的关系，如图所示










②使用用户线程（User Thread,UT）


定义：广义上认为一个线程不是内核线程就是用户线程；狭义上认为用户线程指的是完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现。

优点：由于用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，甚至可以不需要切换到内核态，所以操作非常快速且低消耗的，且可以支持规模更大的线程数量。

缺点：由于没有系统内核的支援，所有的线程操作都需要用户程序自己处理，线程的创建、切换和调度都是需要考虑的问题，实现较复杂。

一对多的线程模型进程：进程与用户线程之间1：N的关系，如图所示








③使用用户线程加轻量级进程混合


定义：既存在用户线程，也存在轻量级进程。

优点：用户线程完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发；操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。

多对多的线程模型：用户线程与轻量级进程的数量比不定，即用户线程与轻量级进程之间N：M的关系，如图所示









那么Java线程的实现是选择哪一种呢？答案是不确定的。操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。线程模型只对线程的并发规模和操作成本产生影响，而对Java程序的编码和运行过程来说，这些差异都是透明的。

b.Java线程调度的两种方式

线程调度：指系统为线程分配处理器使用权的过程。

①协同式线程调度（Cooperative Threads-Scheduling）

由线程本身来控制线程的执行时间。线程把自己的工作执行完后，要主动通知系统切换到另外一个线程上。

好处：实现简单；切换操作自己可知，不存在线程同步的问题。

坏处：线程执行时间不可控，假如一个线程编写有问题一直不告知系统进行线程切换，那么程序就会一直被阻塞。

②抢占式线程调度（Preemptive Threads-Scheduling）

由系统来分配每个线程的执行时间。

好处：线程执行时间是系统可控的，不存在一个线程导致整个进程阻塞的问题。
可以通过设置线程优先级，优先级越高的线程越容易被系统选择执行。


但是线程优先级并不是太靠谱，一方面因为Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，在一些平台上不同的优先级实际会变得相同；另一方面优先级可能会被系统自行改变。

c.线程的五种状态
在任意一个时间点，一个线程只能有且只有其中的一种状态：


新建（New）：线程创建后尚未启动

运行（Runable）：包括正在执行（Running）和等待着CPU为它分配执行时间（Ready）两种

无限期等待（Waiting）：该线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期等待状态：

没有设置Timeout参数的Object.wait()

没有设置Timeout参数的Thread.join()

LockSupport.park()



限期等待（Timed Waiting）：该线程不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒。以下方法会让线程进入限期等待状态：

Thread.sleep()
设置了Timeout参数的Object.wai()

设置了Timeout参数的Thread.join()

LockSupport.parkNanos()
LockSupport.parkUntil()



阻塞（Blocked）：线程被阻塞


注意区别：

阻塞状态：在等待获取到一个排他锁，在另外一个线程放弃这个锁的时候发生；
等待状态：在等待一段时间或者唤醒动作的发生，在程序等待进入同步区域的时候发生。




结束（Terminated）：线程已经结束执行

下图是线程状态之间的转换：
