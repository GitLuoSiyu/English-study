###前言
快速排序，是从冒泡排序演变而来的算法，也属于交换排序，但是比冒泡算法高效很对，因此得名，也是最经典的排序算法之一，它的核心思想就是分治（小伙伴还记不记得前面介绍的Fish-Redux的核心思想也是分治），快速排序拥有良好的时间复杂度，平均为O(nlog2n)，最差为O(n2)。

###快速排序
快速排序通过元素之间的比较和交换位置来达到排序的目的，不同的是，冒泡排序在每一轮只把一个元素冒泡到数组的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。这是分治思想的主要体现，原数组在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 O（nlogn）。

######题目背景
```
// 栗子
var array = [2, 9, 4, 3, 8, 6, 2, 1, 5, 4, 7, 3, 8, 4, 9 , 3, 5, 2]
```


######JS实现
```
// JS
function quickSort(arr) {
	let piovtIndex = Math.floor(arr.length/2);
	if(arr.length<=1) return arr;
	let piovt = arr.splice(piovtIndex,1)[0];
	let _left = []
	let _right = []
	for (var i = 0; i < arr.length; i++) {
		let item = arr[i];
		if(item<piovt) {
			_left.push(item)
		} else {
			_right.push(item)
		}
	}
	return quickSort(_left).concat([piovt],quickSort(_right))
}
```

######C++实现
```
// C++
#include <iostream>
using namespace std;

void quickSort(int* arr, int start, int end) {
    if (start < end) {
        int i = start, j = end;
        while (i < j) {
            while (arr[i] <= arr[j] && i < j) {
                j--;
            }
            if (i < j) {
                arr[i] = arr[i] ^ arr[j];
                arr[j] = arr[i] ^ arr[j];
                arr[i] = arr[i] ^ arr[j];
                i++;
            }
            while (arr[i] < arr[j] && i < j) {
                i++;
            }
            if (i < j) {
                arr[i] = arr[i] ^ arr[j];
                arr[j] = arr[i] ^ arr[j];
                arr[i] = arr[i] ^ arr[j];
                j--;
            }
        }
        quickSort(arr, i + 1, end);
        quickSort(arr, start, i - 1);
    }
}

int main()
{
    int arr[] = {
        2, 9, 4, 3, 8, 6, 2, 1, 5, 4, 7, 3, 8, 4, 9 , 3, 5, 2
    };
    quickSort(arr, 0, 17);
    for (int i = 0; i < 18; i++) {
        cout << arr[i] << "   ";
    }
    cout << endl;
    return 0;
}

// 或者
#include <iostream>
using namespace std;

void quickSort(int* arr, int start, int end)
{
    if (start < end) {
        int i = start, j = end, store = arr[start];
        while (i < j) {
            while (i < j && arr[j] >= store) {
                j--;
            }
            if (i < j) {
                arr[i] = arr[j];
            }
            while (i < j && arr[i] < store) {
                i++;
            }
            if (i < j) {
                arr[j] = arr[i];
            }
        }
        arr[i] = store;
        quickSort2(arr, i + 1, end);
        quickSort2(arr, start, i - 1);
    }
}

int main() {
    int arr[] = {
        2, 9, 4, 3, 8, 6, 2, 1, 5, 4, 7, 3, 8, 4, 9 , 3, 5, 2
    };
    quickSort(arr, 0, 17);
    for (int i = 0; i < 18; i++) {
        cout << arr[i] << "   ";
    }
    cout << endl;
    return 0;
}
```


######局限性：
如果出现一种原本逆序的数组，采用最原始的快速排序的画，就无法发挥分治法的优势了，在最坏情况下，快速排序需要进行N轮比较，时间复杂度会退化到O(N^2)；此外，如果随机选取的基准元素是数组中的最大值or最小值也会到导致分治思想瓦解。
为了避免以上的情况，这个基本元素pivot的选取就需要分情况，pivot的选取直接影响排序的优劣。
①.最简单的方式是选择数列的第一个元素；这种选择在绝大多数情况是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，这种排序效率将降到最低。
②.随机选择一个元素作为基准元素；这样即使在数列完全逆序的情况下，也可以有效地将数列分成两部分，但是这样基本元素随机性较强，时间复杂度也不稳定，平均时间复杂度是 O（nlogn），如果选中了数组中最大值or最小值，最坏情况下的时间复杂度是 O（n^2）。
③.挖坑法，用法是闲选定基准元素 pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素；接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中，最终实现比基准元素小的元素全部移到leftr区域，比基准元素大的元素的移动到right区域，从而实现排序。


④.指针交换法，

```
// 实现

```

###总结
三种方法比较：

指针移动方向：前后指针法比较特别，两指针都是朝一边移动（另外两个方法两指针移动方向不同）。

两指针的完成顺序：左右指针法是两指针都移动到位了，才执行交换，填坑法只要一个指针到位了就执行交换。

两指针的作用：可以说左右指针法和填坑法是相同的。而前后指针法中一个指针决定了插入的位置，一个指针用来检索元素。

最后key值的插入：前后指针法是后指针到头后，交换key值和array[i]（也就是前一个指针指向的值）。左右指针法和填坑法都是在两指针相遇后将key值与指针重合位置的值交换。
