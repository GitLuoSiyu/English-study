###前言
在web端，JS绝对是最火最普遍的编程语言之一，学习成本也不高（据说JS的设计者Brendan花了十天写出了JavaScript），一直具有很大的用户群体。随着node.JS的普及，给原有的前端生态圈注入了新鲜血液，同时前端真正被独立出来，拥有不懂动摇的地位。而JavaScript是一门基于对象的解释性语言，目前主要用户web端开发，鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行，同时JS主要的依赖环境就是浏览器，随着浏览器的不断发展，前端页面不再单单是简单的表单验证时代，为了更快的解析并执行JS脚本，于是就诞生了JS引擎。


JS引擎，是执行JavaScript代码的程序或解释器。JS引擎可以实现为标准解释器，为了提高性能，V8引擎会把js代码转换为高效的机器码，而不在是依赖于解释器去执行。v8引入了JIT在运行时把js代码进行转换为机器码。除了熟悉的V8引擎之外，常见的JS引擎还有：SpiderMonkey、Rhin、KJS 、Chakra、Nashorn 、JerryScript等等


###V8引擎
V8是由C++开发的，一般用于谷歌浏览器chrome，安卓浏览器，node.js等大型项目当中，V8引擎可以独立运行不依赖于其他环境，也可以嵌入任何的C++应用当中使用。
V8引擎曾经有2个编译器：full compiler 和 crankshaft（后来在5.9版本后被消除），这里暂不深究，只对V8的渲染机制进行讨论，有兴趣的同学可以自行谷歌。

#####特性1.隐藏类
JavaScript访问对象属性的时候是通过匹配字符串的形式来查找的，而V8借鉴了C++语言中类和偏移位置的思想，实现了隐藏类，将对象按照属性是否相同划分到不同的组当中，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。假如对象中新增了新的属性，那么这个对象就会被划分到一个新的隐藏类当中。

作者：Eason_Wong
链接：https://www.jianshu.com/p/332c15fd7c7d
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

#####特性2.GC机制
JavaScript使用了垃圾回收的机制，也意味着程序中是不能对内存进行管理的，这样的好处是无需程序员来额外操作内存问题，防止内存泄漏。


###JavaScriptCore
JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，最初性能不是很好，经过后续的迭代和优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。WebKit诞生于1998年，并于2005年由Apple公司开源，Google的Blink也是在 WebKit 的分支上进行开发的。WebKit由多个重要模块组成，通过下图我们可以对WebKit有个整体的了解：
// 

可以理解为 WebKit 就是负责页面渲染、逻辑处理的引擎，前端同学用HTML、CSS、JS作为输入，经过 WebKit 解析和处理，就输出成了我们能看到以及操作的Web页面。从上图我们可以看出来，WebKit由图中框住的四个部分组成。而其中最主要的就是WebCore和JSCore（或者是其它JS引擎），这两部分我们会分成两个小章节详细讲述。除此之外，WebKit Embedding API是负责浏览器UI与WebKit进行交互的部分，而WebKit Ports则是让Webkit更加方便的移植到各个操作系统、平台上，提供的一些调用Native Library的接口，比如在渲染层面，在iOS系统中，Safari是交给CoreGraphics处理，而在Android系统中，Webkit则是交给Skia。
// 
在上面的WebKit组成图中，我们可以发现只有WebCore是红色的。这是因为时至今日,WebKit已经有很多的分支以及各大厂家也进行了很多优化改造，唯独WebCore这个部分是所有WebKit共享的。WebCore是WebKit中代码最多的部分，也是整个WebKit中最核心的渲染引擎。那首先我们来看看整个WebKit的渲染流程：
浏览器根据URL发送请求，服务器响应并正常返回数据之后，浏览器首先①.处理 HTML 并构建 DOM 树；②.处理 CSS 构建 CSSOM 树；③.将 DOM 与 CSSOM 合并成一个渲染树；④.根据渲染树来布局，计算每个节点的位置；⑤.调用 GPU 绘制，合成图层，再经过布局与具体WebKit Ports的渲染接口，把渲染树渲染输出到屏幕上，成为了最终呈现在用户面前的Web页面。

###V8与JSCore
0.JavaScriptCore的大致流程：JavaScript源代码 -> 抽象语法树（AST）-> 字节码-> 本地代码
V8的大致流程：JavaScript源代码 -> 抽象语法树（AST）-> 本地代码 （2017年4月发布5.9版本后新增了Ignition字节码解释器，与JScore流程大致相同）

1.V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。

2.V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。




###V8的GC机制
V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

#### 1.新生代算法
新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

#### 2.老生代算法
老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

在讲算法前，先来说下什么情况下对象会出现在老生代空间中：

新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
老生代中的空间很复杂，有如下几个空间
```
enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象

  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
};
```
在老生代中，以下情况会先启动标记清除算法：

某一个空间没有分块的时候
空间中被对象超过一定限制
空间不能保证新生代中的对象移动到老生代中
在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。

#####特别说明
虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。

###后记
严格的讲，语言本身并不存在编译型或者是解释型，因为语言只是一些抽象的定义与约束，并不要求具体的实现，执行方式。这里讲JS是一门“解释型语言”只是JS一般是被JS引擎动态解释执行，而并不是语言本身的属性。

