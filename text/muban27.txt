###前言



###JS继承
#####ES5继承
在 ES5 中，我们可以使用如下方式解决继承的问题:
```
function Super() {}
Super.prototype.getNumber = function() {
 return 1
}
function Sub() {}
let s = new Sub()
Sub.prototype = Object.create(Super.prototype, {
 constructor: {
 value: Sub,
 enumerable: false,
 writable: true,
 configurable: true
 }
})
```
#####ES6继承
在 ES6 中，我们可以通过 class 语法轻松解决这个问题:
```
class MyDate extends Date {
 test() {
 return this.getTime()
 }
}
let myDate = new MyDate()
myDate.test()
```
但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。
如果你使用编译过得代码调用 myDate.test() 你会惊奇地发现出现了报错。
//图
因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调用
Date 里的函数的。所以这也侧面的说明了：ES6 中的 class 继承与 ES5 中的一般继
承写法是不同的。
既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承
```
function MyData() {
}
MyData.prototype.test = function () {
 return this.getTime()
}
let d = new Date()
Object.setPrototypeOf(d, MyData.prototype)
Object.setPrototypeOf(MyData.prototype, Date.prototype)
```
以上继承实现思路：先创建父类实例 => 改变实例原先的 _proto__ 转而连接到子
类的 prototype => 子类的 prototype 的 __proto__ 改为父类的 prototype。
通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。

###call,apply,bind
首先说下前两者的区别。
call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方
式不同。
除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。
```
let a = {
 value: 1
}
function getValue(name, age) {
 console.log(name)
 console.log(age)
 console.log(this.value)
}
getValue.call(a, 'yck', '24')
getValue.apply(a, ['yck', '24'])
```
#####模拟实现 call 和 apply
可以从以下几点来考虑如何实现
不传入第一个参数，那么默认为 window
改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对
象添加一个函数，然后在执行完以后删除？
```
Function.prototype.myCall = function (context) {
 var context = context || window
 // 给 context 添加一个属性
 // getValue.call(a, 'yck', '24') => a.fn = getValue
 context.fn = this
 // 将 context 后面的参数取出来
 var args = [...arguments].slice(1)
 // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
 var result = context.fn(...args)
 // 删除 fn
 delete context.fn
 return result
}
```
以上就是 call 的思路，apply 的实现也类似
```
Function.prototype.myApply = function (context) {
 var context = context || window
 context.fn = this
 var result
 // 需要判断是否存储第二个参数
 // 如果存在，就将第二个参数展开
 if (arguments[1]) {
 result = context.fn(...arguments[1])
 } else {
 result = context.fn()
 }
 delete context.fn
 return result
}
```
bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可
以通过 bind 实现柯里化。同样的，也来模拟实现下 bind
```
Function.prototype.myBind = function (context) {
 if (typeof this !== 'function') {
 throw new TypeError('Error')
 }
 var _this = this
 var args = [...arguments].slice(1)
 // 返回一个函数
 return function F() {
 // 因为返回了一个函数，我们可以 new F()，所以需要判断
 if (this instanceof F) {
 return new _this(...args, ...arguments)
 }
 return _this.apply(context, args.concat(...arguments))
 }
}
```


###柯里化
先举个例子

```
function add(a){
  function s(b){
    a = a + b
    return s
  }
  s.toString = function(){
    return a
  }
}
// 
console.log(add(129)(2)(3)(4))
// 123+2+3+4 = 129
```

给function对象定义一个after功能，入参是一个函数，当绑定after功能的function函数执行时
，它会执行入参函数并入参function对象的执行结果。例如：
```
let fun = function(f){
  return f()
}
after((res) => {
  console.log(res)
})
fun(() => "你好")
// 打印你好

let after = (fn, ...args) => fn.length <= args.length ? fn(...args) : after.bind(null, fn, ...args)
let fun = after (function(res){
  console.log(res)
})
fun("你好")
```


###this的寿命
介绍完了this的相关，下面进入正文，this的寿命。
this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就
可以了。
```
function foo() {
console.log(this.a)
}
var a = 2
foo()
var obj = {
a: 2,
foo: foo
}
obj.foo()
// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况
// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo()
c.a = 3
console.log(c.a)
// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```
以上几种情况明白了，很多代码中的 this 应该就没什么问题了，下面让我们看看
箭头函数中的 this
```
function a() {
 return () => {
 return () => {
 console.log(this)
 }
 }
}
console.log(a()()())
```
箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是
箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，
所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。

执行上下文
当执行 JS 代码时，会产生三种执行上下文
? 全局执行上下文
? 函数执行上下文
? eval 执行上下文
每个执行上下文中都有三个重要的属性
变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中
访问
作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）
this
var a = 10
function foo(i) {
 var b = 20
}
foo()
对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。
stack = [
 globalContext,
 fooContext
]
对于全局上下文来说，VO 大概是这样的
globalContext.VO === globe
globalContext.VO = {
 a: undefined,
foo: <Function>,
}
对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO）
fooContext.VO === foo.AO
fooContext.AO {
 i: undefined,
b: undefined,
 arguments: <>
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调用者
对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过
[[Scope]] 属性查找上级变量
fooContext.[[Scope]] = [
 globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
 fooContext.VO,
 globalContext.VO
]
接下来让我们看一个老生常谈的例子，var
b() // call b
console.log(a) // undefined
var a = 'Hello world'
function b() {
console.log('call b')
}
想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常
提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。
但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建
的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们
提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为
undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。
在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升
b() // call b second
function b() {
console.log('call b fist')
}
function b() {
console.log('call b second')
}
var b = 'Hello world'
var 会产生很多错误，所以在 ES6 中引入了 let。let 不能在声明前使用，但是
这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并
不能在声明前使用。
对于非匿名的立即执行函数需要注意以下一点
var foo = 1
(function foo() {
 foo = 10
 console.log(foo)
}()) // -> ? foo() { foo = 10 ; console.log(foo) }
因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，
然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这又个值
是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也
没有发生更改。

specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // remove specialObject from the front of scope chain






###前言
维基百科：在计算机科学中，柯里化（Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。


###科里化面试题
在前端面试中有一个关于柯里化的面试题，流传甚广
```
// 实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6
add(1, 2, 3)(4) = 10
add(1)(2)(3)(4)(5) = 15
```
很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。

######1.如果只调用2次
```
function add(a) {
    return function(b) {
        return a + b;
    }
}

console.log(add(1)(2));  // 3
```
######2.如果只调用3次
```
function add(a) {
    return function(b) {
        return function (c) {
            return a + b + c;
        }
    }
}

console.log(add(1)(2)(3)); // 6
```
######3.如果调用的次数不确定？
其实上面的做法都是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。可以这样写个小结：
```
function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = [].slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var adder = function () {
        var _adder = function() {
            [].push.apply(_args, [].slice.call(arguments));
            return _adder;
        };

        // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
        _adder.toString = function () {
            return _args.reduce(function (a, b) {
                return a + b;
            });
        }

        return _adder;
    }
    return adder.apply(null, [].slice.call(arguments));
}

// 输出结果，可自由组合的参数
console.log(add(1, 2, 3, 4, 5));  // 15
console.log(add(1, 2, 3, 4)(5));  // 15
console.log(add(1)(2)(3)(4)(5));  // 15
```
利用闭包的特性通过一些方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。


###函数科里化
函数柯里化就是创建已经设置单个参数或者多个参数的函数，函数变为接受一个参数，返回一个值，柯里化的用途主要是参数复用。再举一个 demo ：
```
// 参数复用
function add(a, b) {
    return a + b;
}
add(1,2)  //3

// 柯里化之后可以这样
var addCurry = curry(add);
addCurry(1)(2); //3
```
或许针对这种简单的将两个数相加的场景，柯里化显得有点多余。但是如果我们想使用这个函数完成通用的事情，比如为所有的数加5，就可以使用addCurry(5)(x)，使得将两个数相加的函数有了通用性。

######通用版
```
var curry = function(func){
    
    var args = [].slice.call(arguments,1);
    
    return function(){
        
        var newArgs = args.concat([].slice.call(arguments));
        
        return func.apply(this,newArgs);
    
    }

}
```
首先将参数进行分割，也就是将除了func之外的参数存进args。
返回的函数接受新传入的参数并与之前的参数合并，从而将所有的参数传入函数中，并执行真正的函数。

######改进版
比如说add这个函数接受两个参数，那么针对柯里化之后的函数，若传入的参数没有到达两个的话，就继续调用curry，继续接受参数。若参数到达2个了，就直接调用add函数。
```
var curry = function(func,args){
    
    var length = func.length;
    
    args = args||[];

  
  
    return function(){
        
        newArgs = args.concat([].slice.call(arguments));
        
        if(newArgs.length < length){
            
            return curry.call(this,func,newArgs);
        
        }else{
            
            return func.apply(this,newArgs);
        
        }
    
    }


}

var addCurry = curry(add);
addCurry(1,2) //3
addCurry(1)(2) //3
```
######进阶版
但这一版柯里化函数仍然不能完全满足要求，因为它只针对有特定参数个数的函数适用。 
在前端面试中有一个关于柯里化的面试题：
```
实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6
add(1, 2, 3)(4) = 10
add(1)(2)(3)(4)(5) = 15
```
前面写的已经不能满足需求，这里就需要使用函数的toString来完成。 
当我们返回函数的时候，会调用函数的toString来完成隐式转换，这样输出的就不是函数的字符串形式而是我们定义的toString返回的值。这样就既可以保持返回一个函数，又能够得到一个特定的值。
```
function add(){
    
    // 第一次执行时，定义一个数组专门用来储存所有的参数
   
    var args = [].slice.call(arguments);
 
    // 在内部声明一个函数，
   
    // 利用闭包的特性保存_args并收集所有的参数值
      
    var fn = function(){
        
        var newArgs = args.concat([].slice.call(arguments));
        
        return add.apply(null,newArgs);
    
    } 
    
    // 利用隐式转换的特性，
   
    // 当最后执行时隐式转换，并计算最终的值返回
   
    fn.toString = function(){
        
        return args.reduce(function(a, b) {
            
            return a + b;
        
        })
    
    }
    
    return fn ;

}

// 可以接受任意个数的参数
add(1)(2,3) //6
add(1)(2)(3)(4)(5) //15
```

######真正的函数柯里化
无论是上面的面试题还是demo，我们从中不难看出，柯里化是将接受多个参数转换为接受一个单一参数。简单梳理一下：
假设你有一个储钱罐 countMoney 函数，和一个记录本 arr 数组，当你每月有空钱时进行储存，每次在 arr 中记录一次，存入储钱罐中：
```
var arr=[];
var countMoney=function(arr){
    var sum=0;
	for(var i=0;i<arr.length;i++){
    	sum+=arr[i];
    }
    return sum;
}

arr.push(1);
arr.push(2);

countMoney(arr);
```
可以通过这种方式来进行存储，但是有本记录，是会被发现的，所以这个时候可以这样：
```
// 每次存储是调用一次，不需要再次记录下来
countMoney(1);
countMoney(2);

// 等到真正需要的时候我们可以直接计算出来这个总值
countMoney(); //3
```
于是问题解决的方式变为柯里化问题，需要将多个参数接受转换为接受单一参数的问题。于是我们可以使用下面的方式进行处理.
```
var countMoney = (function() {
    let moneys = 0;
    let arr = [];

    var result = function() {
        // 判断是否还有参数，如果没有，则返回存储起来值的总和
        if(arguments.length == 0) {
            for(var i = 0; i < arr.length; i++) {
                money += arr[i];
            }
            return money;
        } else {
            // arguments 是个类数组来着，应该用展开符展开才能push进去
            // 通过arguments 处理可以传入多个参数值
            console.log(...arguments)
            arr.push(...arguments);
            return result;
        }
    }
    return result;
})();

countMoney(1)(2)(3)
countMoney(6)
```
上面的例子完全可以实现柯里化，并且进行扩展，现在可以安全的存放钱了。


######总结
柯里化（Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。

接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。
将部分参数通过回调函数等方式传入函数中
返回一个新函数，用于处理所有的想要传入的参数。

实际上，在JavaScript的很多思想和设计模式中，闭包是个很常见的且很重要的东西，上面两个例子代码中，本质上就是利用了闭包。上面的 countMoney 函数是个立即执行的函数，返回一个新函数，而这个新函数实际上就是一个闭包，这个新函数把每次接收到的参数都存储起来，并且继续返回一个新函数，当发现某次调用时没有传入参数，那就意味着要进行数据统计，从而把之前存储的数据一次拿出来计算，最后返回计算结果。





























