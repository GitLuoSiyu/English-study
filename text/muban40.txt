###前言
昨天总结JS知识点的时候，涉及到跨越环节，我直接一笔带过，仔细想想，之前有个傻傻的面试官居然告知我JSONP不算跨域，当然忍住了没怼他。不过今天还是下决心写一篇跨域总结。

###跨域背景
- 同域
同域：协议、域名、端口号均相同

- 跨域：
跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。

- 同源策略：
同源策略由Netscape公司1995年引入浏览器，协助浏览器免受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
```
URL                                      说明                    是否允许通信
http://www.demo.com/a.js
http://www.demo.com/b.js         同一域名，不同文件或路径           允许
http://www.demo.com/lab/c.js

http://www.demo.com:8000/a.js
http://www.demo.com/b.js         同一域名，不同端口                不允许
 
http://www.demo.com/a.js
https://www.demo.com/b.js        同一域名，不同协议                不允许
 
http://www.demo.com/a.js
http://127.0.0.1/b.js           域名和域名对应相同ip              不允许
 
http://www.demo.com/a.js
http://x.demo.com/b.js           主域相同，子域不同                不允许
http://demo.com/c.js
 
http://www.demo1.com/a.js
http://www.demo2.com/b.js        不同域名                         不允许
```

###跨域行为
ajax请求 XMLHttpRequest
注意：浏览器并不会限制跨域请求的发出，即服务端再未做其他限制的情况下仍可收到跨域请求，浏览器只是限制了ajax请求返回信息的读取、cookie写入等操作
扩展：服务端如何限制仅接收指定域名请求? refer?
fetch
非同域窗体之间（比如iframe引入的情况的父子窗体）不能直接进行数据通讯或共享
Web 字体 (CSS 中通过 @font-face 使用跨域字体资源)
WebGL 贴图
使用 drawImage 将 Images/video 画面绘制到 canvas

跨域报错：
// 图



###解决方案
1、 通过jsonp跨域
JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。JSONP 使用简单且兼容性不错，但是只限于 get 请求，不可能支持post请求。在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现
```
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement("script");
  script.src = url;
  script.async = true;
  script.type = "text/javascript";
  window[jsonpCallback] = function(data) {
    success & success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  "http://xxx",
  "callback",
  function(value) {
    console.log(value);
  }
);
```
应用场景：淘宝和天猫通过jsonp跨域共享cookie，在淘宝(www.taobao.com)登录后，切换到天猫(www.tmall.com)，会看到顶栏已经有登录用户信息。打开控制台，刷新tmall页面，可以看到如下jsonp请求。
优点：
缺点：如果动态脚本插入有效，就执行调用；如果无效，就静默失败：不能从服务器捕捉到 404 错误，也不能取消或重新开始请求。（自行设置定时器，超时后没有进入回调即判定为请求失败 ）



2、 CORS
CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
应用场景：
优点：
缺点:

2、 document.domain + iframe跨域
该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域。
应用场景：
优点：
缺点:

3、 location.hash + iframe
该方案是依赖消息通信机制实现，原理是在目标服务器放置一个代理文件(proxy_frame.html)，通过加载该代理文件和服务端进行数据交互（同域请求），返回数据通过消息通讯(如post message)返回给上层应用以实现跨域数据交互a.b.com域页面。实际上是利用窗体之间通讯方式 将跨域请求转化为同域请求。
应用场景：
优点：
缺点:


4、 window.name + iframe跨域
该方案也是依赖消息通信机制实现
应用场景：
优点：
缺点:


5、 postMessage跨域
该方案也是依赖消息通信机制实现，这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。
```
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
  var origin = event.origin || event.originalEvent.origin;
    if (origin === 'http://test.com') {
      console.log('验证通过')
    }
});
```

应用场景：
优点：
缺点:

6、 跨域资源共享（CORS）
通过增加一系列请求头和响应头，规范安全地进行跨站数据传输，它要求浏览器必须能支持CORS规范定义的请求头和策略执行，并且服务端需要解析这些新的请求头并按照策略返回对应的响应头和请求的资源。

应用场景：
优点：
缺点:


7、 nginx代理跨域
将本域服务端配置成 需要跨域获取的资源的 反向代理服务器，比如：使用Nginx配置请求转发：proxy_pass。

应用场景：
优点：
缺点:

8、 nodejs中间件代理跨域


应用场景：
优点：
缺点:

9、 WebSocket协议跨域
建立socket长连接，需要验证，本质上可以视为安全，不存在跨域限制,由于资源消耗较大，除了一些特殊场景，一般不使用.


10、Flash代理跨域
与frame代理模式类似，请求通过Flash来发送(proxy_flash.swf放置在同源站)，利用Flash的策略文件crossdomain.xml来控制资源的共享权限，获取目标服务器请求返回数据---相当于把iframe改成flash。


###总结
针对少量需要跨域Get请求的场景 ： JSONP仍是不错的选择
针对整站大量跨域请求 ： 
―― 兼容性要求高： iFrame代理跨域/服务端反向代理

―― IE10以上兼容支持： CORS规范

检测浏览器支持： 高版本使用CORS规范，低版本自动降级使用iFrame代理




