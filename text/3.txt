###前言
冒泡排序的英文Bubble Sort，是一种最基础的交换排序。而我们的冒泡排序之所以叫做冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。

###冒泡排序
######题目背景
```
// 栗子
var array = [5,6,1,3,2,9,17,11]
```
按照冒泡排序的思想，我们要把相邻的元素两两比较，根据大小来交换元素的位置，过程如下：首先让5和6比较，发现5比6要小，因此元素位置不变。接下来让6和1比较，发现6比1要大，所以6和1交换位置，后面依次如此。这样一来，元素17作为数组的最大元素，就像是汽水里的小气泡一样漂啊漂，漂到了最右侧。这时候，我们的冒泡排序的第一轮结束了。数组最右侧的元素17可以认为是一个有序区域，有序区域目前只有一个元素。
第二轮循环开始，过程跟上面一样，最后确认了11是第二大，第二轮排序结束后在数组右侧的有序区有了2个元素（17,11）。经过7轮排序之后（因为第八轮只有一个元素不发生比较），整个数组就是有序的了。这就是冒泡排序最简易的整体思路（有待优化的）。
```
// 冒泡排序第一版本， Java 实现 
	public static void sort(int array[]) {
		int temp = 0;
		for(int i = 0; i > array.length; i++) {
			for(int j = 0; j < array.length - i - 1; j++) {
				if(array[j] > array[j+1]) {
					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
				}
			}
		}
	}
	
	public static void main(String[] args) {
		int [] array = new int[] {5,6,1,3,2,9,17,11};
		sort(array);
		System.out.println(Arrays.toString(array));
	}
```
代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮的冒泡处理，先进行元素比较，再进行元素交换。

上述原始的冒泡排序写法，无论在领扣还是面试环节，都是不合格的，因为需要优化的环节很多，让我们回顾一下刚才描述的排序细节，仍然以5,6,1,3,2,9,17,11 这个数组为例，当排序算法分别执行到第六、第七、第八轮的时候，数列状态如下：
```
// 第6轮
1 2 3 5 6 9 11 17

// 第7轮
1 2 3 5 6 9 11 17

// 第8轮
1 2 3 5 6 9 11 17
```
很明显可以看出，自从经过第六轮排序，整个数列已然是有序的了。可是我们的排序算法仍然“兢兢业业”地继续执行第七轮、第八轮。这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。
```
// 改版后， Java 实现 
	public static void sort(int array[]) {
		int temp = 0;
		for(int i = 0; i < array.length; i++) {
			// 有序标记，每一轮排序的初始值都是 true
			boolean isSorted = true;
			for(int j = 0; j < array.length - i - 1; j++) {
				if(array[j] > array[j+1]) {
					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
					// 如果有元素交换，说明不是有序的，标记改成false
					isSorted = false;
				}
			}
			if(isSorted) {
				break;
			}
		}
	}
	public static void main(String[] args) {
		int [] array = new int[] {5,6,1,3,2,9,17,11};
		sort(array);
		System.out.println(Arrays.toString(array));
	}
```
这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。

第二步优化：
针对5,6,1,3,2,9,17,11，我们可以发现 前5个无序，后面3个有序，按照原来的写法，后面的已经有序了，可是每轮排序比较会浪费了一些比较次数。这个问题的关键点在哪里呢？关键在于对数列有序区的界定。
按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2 ......
实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。
如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。
```
// 二次优化，Java 实现 
	public static void sort(int array[]) {
		int temp = 0;
		int lastExchangeIndex = 0;  
		// 记录最后一次交换的位置
		
		int sortBorder = array.length - 1;
		// 设置数组的边界，即比较的边界，避免多余比较
		for(int i = 0; i < array.length; i++) {
			// 有序标记，每轮的初始值均为 true
			boolean isSorted = true;
			for(int j = 0; j < sortBorder; j++) {
				if(array[j] > array[j+1]) {
					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
					
					// 如果有元素发生了交换，标记为 false
					isSorted = false;
					
					// 把无序数组的比较边界更新为 最后一次交换元素的位置
					lastExchangeIndex = j;
				}
			}
			sortBorder = lastExchangeIndex;
			if(isSorted) {
				break;
			}
		}
	}
	
	public static void main(String[] args) {
		int [] array = new int[] {5,6,1,3,2,9,17,11};
		sort(array);
		System.out.println(Arrays.toString(array));
	}
```
这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。

######JS实现
```
// JS


```

######C++实现
```
// C++

```


######局限性：
冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮从都是从左到右比较元素，进行单向的位置交换。仅仅减少每次的排序次数并加以判断，还是不够的，冒泡排序的时间复杂度是O(n^2)还是比较大。针对冒泡排序作出优化，后面产生了优化版的冒泡排序，鸡尾酒排序。


###鸡尾酒排序
鸡尾酒排序的元素比较和交换过程是双向的。
```
// 栗子
var array = [12,13,14,15,16,17,18,11] 
```
如果采用冒牌排序的话会觉得很憋屈，因为明明只有一个元素的位置不对，却需要进行7轮排序。而鸡尾酒排序可以避免这种情况，它首先第一轮从左向右比较、交换，18最终放在数组右侧的有序区；第二轮开始反过来从右往左比较、交换；让11和17比较。元素11小于17，所以11和17交换位置，然后依次11和16比较并交换...最终11回到数组的左侧；虽然数组到此为止已经是有序的，但是第三轮排序仍然在继续，第三轮排序重新从左从左向右比较和交换，发现没有元素位置交换，证明已经有序，排序结束。
排序过程就像钟摆一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右......
```
// Java 实现 
	private static void sort(int array[]) {
		int temp = 0;
		for(int i = 0; i < array.length/2; i++) {
			boolean isSorted = true;
			// 有序标记，每轮的初始值是 true
			// 奇数轮次，每轮从左向右比较和交换
			for (int j = i; j < array.length - i - 1; j++) {
				if(array[j] > array[j+1]) {
					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
					// 如果有元素发生交换，有序标记就更新为 false
					isSorted = false;
				}
			}
			if(isSorted) {
				break;
			}
			
			// 偶数轮之前，将有序标记再更新为 初始值 true
			isSorted = true;
			// 偶数轮排序开始，从右向左比较和交换
			for(int j = array.length - i - 1; j > i; j--) {
				if(array[j] < array[j-1]) {
					temp = array[j];
					array[j] = array[j-1];
					array[j-1] = temp;
					// 如果有元素发生了交换，有序标记更新为false
					isSorted = false;
				}
			}
			if(isSorted) {
				break;
			}
		}
	}
	
	public static void main(String[] args) {
		int [] array = new int[] {5,6,1,3,2,9,17,11};
		sort(array);
		System.out.println(Arrays.toString(array));
	}
```
这段代码是鸡尾酒排序的原始实现。代码外层的大循环控制着所有排序回合，大循环内包含两个小循环，第一个循环从左向右比较并交换元素，第二个循环从右向左比较并交换元素。
原始的冒泡排序，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2 ......
要想优化，我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。
对于单向的冒泡排序，我们需要设置一个边界值，对于双向的鸡尾酒排序，我们需要设置两个边界值。请看代码：
```
	private static void sort(int array[]) {
		int temp = 0;
		
		int lastRightExchangeIndex = 0;
		// 记录右侧最后一次交换的位置
		int lastLeftExchangIndex = 0;
		// 记录左侧最后一次交换的位置
		int rightSortBorder = array.length - 1;
		// 记录右侧比较的边界
		int leftSortBorder = 0;
		// 记录左侧比较的边界
		
		for (int i = 0; i < array.length/2; i++) {
			boolean isSorted = true;
			// 有序标记，每轮的初始值默认是 true
			// 奇数轮，从左向右
			for(int j = leftSortBorder; j < rightSortBorder; j++) {
				if(array[j] > array[j+1]) {
					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
					// 如果有元素发生了比较交换， 有序标记更新为 false
					isSorted = false;
					// 如果有元素发生交换，更新该轮次的比较边界
					lastRightExchangeIndex = j;
				}
			}
			rightSortBorder = lastRightExchangeIndex;
			if(isSorted) {
				break;
			}
			// 在偶数轮比较之前，重新初始化 isSorted 为 true
			isSorted = true;
			// 偶数轮次比较，从右向左比较和交换
			for(int j = rightSortBorder; j > leftSortBorder; j--) {
				if(array[j] < array[j-1]) {
					temp = array[j];
					array[j] = array[j-1];
					array[j-1] = temp;
					// 如果有元素发生了交换，更新 isSorted
					isSorted = false;
					lastLeftExchangIndex = j;
				}
			}
			leftSortBorder = lastLeftExchangIndex;
			if(isSorted) {
				break;
			}
		}
	}
	
	public static void main(String[] args) {
		int [] array = new int[] {5,6,1,3,2,9,17,11};
		sort(array);
		System.out.println(Arrays.toString(array));
	}
```
代码中使用了左右两个边界值，rightSortBorder 代表右边界，leftSortBorder代表左边界。 
在比较和交换元素时，奇数轮从 leftSortBorder 遍历到 rightSortBorder 位置，偶数轮从 rightSortBorder 遍历到 leftSortBorder 位置。

###总结
鸡尾酒排序的优点就是能够在特定的条件下，减少排序的回合数，而缺点也很明显，代码量增多，应用场景主要是"大部分元素已经有序"的情况下。
