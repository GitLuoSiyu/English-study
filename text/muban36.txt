#####15.协同程序(coroutine)
Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。
线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起，协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。

- coroutine.create()
创建coroutine，返回coroutine， 参数是一个函数，当和resume配合使用的时候就唤醒函数调用。

- coroutine.resume()
重启coroutine，和create配合使用。

- coroutine.yield()
挂起coroutine，将coroutine设置为挂起状态，这个和resume配合使用能有很多有用的效果。

- coroutine.status()
查看coroutine的状态，coroutine的状态有三种：dead，suspend，running，具体什么时候有这样的状态请参考下面的程序。

- coroutine.wrap（）
创建coroutine，返回一个函数，一旦你调用这个函数，就进入coroutine，和create功能重复。

- coroutine.running()
返回正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就是返回一个corouting的线程号。

```
function foo (a)
    print("foo 函数输出", a)
    return coroutine.yield(2 * a) // 这里返回  2*a 的值
end
 
co = coroutine.create(function (a , b)
    print("第一次协同程序执行输出", a, b) // co-body 1 10
    local r = foo(a + 1)
     
    print("第二次协同程序执行输出", r)
    local r, s = coroutine.yield(a + b, a - b)  // a，b的值为第一次调用协同程序时传入
     
    print("第三次协同程序执行输出", r, s)
    return b, "结束协同程序"                   // b的值为第二次调用协同程序时传入
end)
        
print("main", coroutine.resume(co, 1, 10)) // true, 4
print("--分割线----")
print("main", coroutine.resume(co, "r")) // true 11 -9
print("---分割线---")
print("main", coroutine.resume(co, "x", "y")) // true 10 end
print("---分割线---")
print("main", coroutine.resume(co, "x", "y")) // cannot resume dead coroutine
print("---分割线---")

// 运行结果：
第一次协同程序执行输出    1    10
foo 函数输出    2
main    true    4
--分割线----
第二次协同程序执行输出    r
main    true    11    -9
---分割线---
第三次协同程序执行输出    x    y
main    true    10    结束协同程序
---分割线---
main    false    cannot resume dead coroutine
---分割线---
```
上面这个demo的运行过程如下：
- 调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；
- 协同程序运行；
- 运行到yield语句；
- yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）
- 第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）
- yield返回；
- 协同程序继续运行；
- 如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine。

resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。






#####16.文件 I/O
和C语言一样，Lua I/O 库用于读取和处理文件。分为简单模式、完全模式。
- 简单模式（simple model）
拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。
```
// 以只读方式打开文件
file = io.open("test.lua", "r")

// 设置默认输入文件为 test.lua
io.input(file)

// 输出文件第一行
print(io.read())

// 关闭打开的文件
io.close(file)

// 以附加的方式打开只写文件
file = io.open("test.lua", "a")

// 设置默认输出文件为 test.lua
io.output(file)

// 在文件最后一行添加 Lua 注释
io.write("--  test.lua 文件末尾注释")

// 关闭打开的文件
io.close(file)

//  io.read() 中参数
//  读取一个数字并返回它: file.read("*n")
//  从当前位置读取整个文件: file.read("*a")
//  读取下一行，在文件尾 (EOF) 处返回 nil ：file.read("*l")
//  返回一个指定字符个数的字符串，或在EOF时返回nil：file.read(5)

// 返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除
io.tmpfile()

// 检测obj是否一个可用的文件句柄
io.type(file)

// 向文件写入缓冲中的所有数据
io.flush()

// 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件
io.lines(optional file name)

```


- 完全模式（complete model）
使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法。

简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。
```
// 以只读方式打开文件
file = io.open("test.lua", "r")

// 输出文件第一行
print(file:read())

// 关闭打开的文件
file:close()

// 以附加的方式打开只写文件
file = io.open("test.lua", "a")

// 在文件最后一行添加 Lua 注释
file:write("--test")

// 关闭打开的文件
file:close()

// 设置和获取当前文件位置,成功则返回最终的文件位置(按字节)
file:seek(optional whence, optional offset)

// 向文件写入缓冲中的所有数据
file:flush()

// 打开指定的文件filename为读模式并返回一个迭代函数,
// 每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。
io.lines(optional file name)

// read 的参数与简单模式一致，不过参数 whence 值可以是:
// "set": 从文件头开始
// "cur": 从当前位置开始[默认]
// "end": 从文件尾开始
// offset:默认为0
```



#####17.错误处理
程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。
我们可以使用两个函数：assert 和 error 来处理错误。assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出；而error函数，会终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)，通常情况下，error会附加一些错误位置的信息到message头部。


pcall 和 xpcall、debug，是处理异常的常用方法，使用函数pcall（protected call）来包装需要执行的代码。pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。pcall以一种"保护模式"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。
```
if pcall(function_name, ….) then
// 没有错误
else
// 一些错误
end
```

Lua提供了xpcall函数，xpcall接收第二个参数――一个错误处理函数，当错误发生时，Lua会在调用C展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。

debug库提供了两个通用的错误处理函数:debug.debug，通过提供一个Lua提示符，让用户来检查错误的原因；debug.traceback，根据调用C来构建一个扩展的错误消息。
```
// 例如
function myfunction ()
   n = n/nil
end

function myerrorhandler( err )
   print( "ERROR:", err )
end

status = xpcall( myfunction, myerrorhandler )
print( status)

// 运行结果：
ERROR:    test2.lua:2: attempt to perform arithmetic on global 'n' (a nil value)
false
```


#####18.调试(Debug)
Lua 提供了 debug 库用于提供创建我们自定义调试器的功能。Lua 本身并未有内置的调试器，但很多开发者共享了他们的 Lua 调试器代码。
Lua 中 debug 库包含以下函数：
```
debug()
// 进入一个用户交互模式，运行用户输入的每个字符串。 

getfenv(object):
// 返回对象的环境变量。

gethook(optional thread):
// 返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数

getinfo ([thread,] f [, what]):
// 返回关于一个函数信息的表。 

debug.getlocal ([thread,] f, local):
// 此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。

getmetatable(value):
// 把给定索引指向的值的元表压入堆栈。

getregistry():
// 返回注册表表。

getupvalue (f, up)
// 此函数返回函数 f 的第 up 个上值的名字和值。

sethook ([thread,] hook, mask [, count]):
// 将一个函数作为钩子函数设入。

setlocal ([thread,] level, local, value):
// 这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。

setmetatable (value, table):
// 将 value 的元表设为 table （可以是 nil）。

setupvalue (f, up, value):
// 这个函数将 value 设为函数 f 的第 up 个上值。 

traceback ([thread,] [message [, level]]):
// 如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。
```


#####19.垃圾回收
Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。

Lua 提供了以下函数collectgarbage ([opt [, arg]])用来控制自动内存管理:
- collectgarbage("collect"): 
做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：

- collectgarbage("count"): 
以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。

- collectgarbage("restart"): 
重启垃圾收集器的自动运行。

- collectgarbage("setpause"): 
将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。

- collectgarbage("setstepmul"): 
返回 步进倍率 的前一个值。

- collectgarbage("step"): 
单步运行垃圾收集器。 步长"大小"由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。

- collectgarbage("stop"): 
停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。

举个代码片段:
```
mytable = {"apple", "orange", "banana"}

print(collectgarbage("count"))

mytable = nil

print(collectgarbage("count"))

print(collectgarbage("collect"))

print(collectgarbage("count"))

// 运行结果：
20.9560546875
20.9853515625
0
19.4111328125
```


#####20.面向对象
Lua 是基于C语言的面向过程语言，lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来，这里并没有实际的class方法。



















