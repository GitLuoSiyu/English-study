###前言
在大厂里，工作高度分工，工程师的全栈其实很少有用武之地，晋升要看他们的工作对业务的帮助。公司要的是业绩，技术的最终价值就应该体现在提升业绩上，这其实是放在任何职业都适合的说辞，在对新技术的追逐上，在对采用何种技术的选型上，很多时候我们为了技术而技术，为了让自己不落伍而学习使用新技术，而并没有从是否适合公司业务的角度去考虑。


###重拾JS相关概念
######1.Null类型
Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因，在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [Object Type] 的字符串。
```
let a
// 我们也可以这样判断 undefined
a === undefined
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1
// 这样判断就会出错
// 所以可以用下面的方式来判断，并且代码量更少
// 因为 void 后面随便跟上一个组成表达式
// 返回就是 undefined
a === void 0
```

######2.new
大家都知道，new的过程主要发生了4件事：
- 新生成了一个对象
- 链接到原型
- 绑定当前this
- 返回新对象

我们也可以试着来自己实现一个 new
```
function create() {
 // 创建一个空的对象
 let obj = new Object()
 // 获得构造函数
 let Con = [].shift.call(arguments)
 // 链接到原型
 obj.__proto__ = Con.prototype
 // 绑定 this，执行构造函数
 let result = Con.apply(obj, arguments)
 // 确保 new 出来的是个对象
 return typeof result === 'object' ? result : obj
}
```
对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = {
b : 1 } 。
对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可
读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到
Object，但是你使用字面量的方式就没这个问题。
```
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()

// 还需要注意下运算符优先级
function Foo() {
 return this;
}
Foo.getName = function () {
 console.log('1');
};
Foo.prototype.getName = function () {
 console.log('2');
};
new Foo.getName(); // -> 1
new Foo().getName(); // -> 2 

```
从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可
以这样划分执行顺序是：先 new (Foo.getName());后(new Foo()).getName();

对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，
所以结果为 2。



######3.闭包
闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的
变量，函数 B 就被称为闭包。
```
function A() {
 let a = 1
 function B() {
 console.log(a)
 }
 return B
}
```
你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数
A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过
逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。
经典面试题，循环中使用闭包解决 var 定义函数的问题
```
for ( var i=1; i<=5; i++) {
setTimeout( function timer() {
 console.log( i );
}, i*1000 );
}?
```
首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i
就是 6 了，所以会输出一堆 6。
解决办法两种，第一种使用闭包
```
for (var i = 1; i <= 5; i++) {
 (function(j) {
 setTimeout(function timer() {
 console.log(j);
 }, j * 1000);
 })(i);
}
```
第二种就是使用 setTimeout 的第三个参数
```
for ( var i=1; i<=5; i++) {
setTimeout( function timer(j) {
 console.log( j );
}, i*1000, i);
}
```
第三种就是使用 let 定义 i 了
```
for ( let i=1; i<=5; i++) {
setTimeout( function timer() {
 console.log( i );
}, i*1000 );
}
```
因为对于 let 来说，他会创建一个块级作用域，相当于
```
{ // 形成块级作用域
 let i = 0
 {
 let ii = i
 setTimeout( function timer() {
 console.log( i );
 }, i*1000 );
 }
 i++
 {
 let ii = i
 }
 i++
 {
 let ii = i
 }
 ...
}
```


######4.CommonJS
CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify 解析了。
```
// a.js
module.exports = {
 a: 1
}
// or
exports.a = 1
// b.js
var module = require('./a.js')
module.a // -> log 1
```
在上述代码中，module.exports 和 exports 很容易混淆，让我们来看看大致内部
实现
```
var module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
 a: 1
}
// 基本实现
var module = {
 exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
 // 导出的东西
 var a = 1
 module.exports = a
 return module.exports
};
```
再来说说 module.exports 和 exports，用法其实是相似的，但是不能对 exports
直接赋值，不会有任何效果。
对于 CommonJS 和 ES6 中的模块化的两者区别是：
? 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是
已有提案
? 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程
影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采
用导入会对渲染有很大影响
? 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如
果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的
值都指向同一个内存地址，所以导入值会跟随导出值变化
? 后者会编译成 require/exports 来执行的


######5.Proxy
Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作
```
let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` 用来自定义对象中的操作
```
可以很方便的使用 Proxy 来实现一个数据绑定和监听
```
let onWatch = (obj, setBind, getLogger) => {
 let handler = {
 get(target, property, receiver) {
 getLogger(target, property)
 return Reflect.get(target, property, receiver);
 },
 set(target, property, value, receiver) {
 setBind(value);
 return Reflect.set(target, property, value);
 }
 };
 return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
 value = v
}, (target, property) => {
 console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

######6.
跨域方式：JSONP、CORS、document.domain、postMessage



######7.MVVM模式
MVVM 由以下三个内容组成
? View：界面
? Model：数据模型
? ViewModel：作为桥梁负责沟通 View 和 Model
在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样
数据和业务的逻辑就和页面有强耦合。
在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI
如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而
无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理
数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要
改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复
用这个 ViewModel。
在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue
中的数据劫持。


######8.前端路由
前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，
显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式：hash模式、- history模式
www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务
器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。

- History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观。
但是需要后端设置。


######9.React V16生命周期
```
class ExampleComponent extends React.Component {
 // 用于初始化 state
 constructor() {}
 // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用
 // 因为该函数是静态函数，所以取不到 `this`
 // 如果需要对比 `prevProps` 需要单独在 `state` 中维护
 static getDerivedStateFromProps(nextProps, prevState) {}
 // 判断是否需要更新组件，多用于组件性能优化
 shouldComponentUpdate(nextProps, nextState) {}
 // 组件挂载后调用
 // 可以在该函数中进行请求或者订阅
 componentDidMount() {}
 // 用于获得最新的 DOM 数据
 getSnapshotBeforeUpdate() {}
 // 组件即将销毁
 // 可以在此处移除订阅，定时器等等
 componentWillUnmount() {}
 // 组件销毁后调用
 componentDidUnMount() {}
 // 组件更新后调用
 componentDidUpdate() {}
 // 渲染组件函数
 render() {}
 // 以下函数不建议使用
 UNSAFE_componentWillMount() {}
 UNSAFE_componentWillUpdate(nextProps, nextState) {}
 UNSAFE_componentWillReceiveProps(nextProps) {}
}
```


###重新认识浏览器
浏览器的请求执行过程，以及三次握手四次挥手，这里不再赘述。我们都知道，一个完整的浏览器组成至少包括：排版引擎（内核）、JavaScript引擎。

- 排版引擎
全称是Layout engine，也称为浏览器内核（web browser engine）、页面渲染引擎（rendering engine）或样版引擎）是一种软件组件，负责获取标记式内容（如HTML、XML及图像文件等等）、整理信息（如CSS及XSL等），并将排版后的内容输出至显示器或打印机。所有网页浏览器、电子邮件客户端以及其它需要根据表示性的标记语言（Presentational markup）来显示内容的应用程序都需要排版引擎。

- JavaScript引擎
之前也有介绍过（文章链接：），JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。常见的有SpiderMonkey，V8等等。

其他JavaScript引擎，Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写，可以看做SpiderMonkey的Java版。 注意：webkit不单单只是一个排版引擎，webkit = 排版引擎 + JavaScript引擎。 > 所以，JavaScript是动态语言，它的运行都是基于JavaScript引擎，引擎大都是由静态语言实现C++、Java、and so on。JavaScript的能力也是由引擎赋予。不管是浏览器环境中是window，亦或是node环境中的process，均是由引擎提供。

在浏览器环境中，DOM、BOM、window对象、setTimeout/setInterval，alert，console等方法均不是JavaScript自身具备的能力，而是浏览器native实现，然后通过JavaScript引擎注入到JS运行的全局上下文中，供JS使用。 鉴别方式，在调试器console中打出来，带有[native code]的都是。

原因：
- JavaScript运行 → 依赖于JavaScript引擎 ← 浏览器集成了JavaScript引擎，同时通过JavaScript引擎注入native代码工JS脚本使用。

- 发散一下思维，只要有JavaScript引擎，就能运行JS脚本，不管有没有浏览器！只是缺少浏览器提供的alert，window等方法。

- 既然浏览器可以往JavaScript引擎中注入代码，赋予JS脚本在网页中特殊的能力，同理我们可以自己集成JavaScript引擎，自己定义自己的方法往JavaScript引擎中注入，赋予JS更多更强的自定义能力。

- 注入的关键是：值类型相互对应，Obj映射class的一个实例，function映射一个句柄或者引用








