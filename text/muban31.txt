###前言
防抖（Debounce）和节流（throttle）都是用来控制某个函数在一定时间内执行多少次的技巧，两者相似而又不同。

###应用场景
######防抖场景
连续的事件，只需触发一次回调的场景有：

1.搜索框搜索输入。只需用户最后一次输入完，再发送请求
2.手机号、邮箱验证输入检测
3.窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

######节流场景
间隔一段时间执行一次回调的场景有：

1.滚动加载，加载更多或滚到底部监听
2.谷歌搜索框，搜索联想功能
3.高频点击提交，表单重复提交

###函数防抖
这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回
调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一
个精确点做操作。
类似表单提交or登陆的业务操作，包括注册框的正则验证，如果一个事件被频繁触发多次，并且触发的时间间隔过短，则防抖函数可以使得对应的事件处理函数只执行一次。
```
/**
 * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗口的间隔
 * @param {boolean} immediate 设置为ture时，是否立即调用函数
 * @return {function} 返回客户调用函数
 */
_.debounce = function(func, wait, immediate) {
 var timeout, args, context, timestamp, result;
 var later = function() {
 // 现在和上一次时间戳比较
 var last = _.now() - timestamp;
 // 如果当前间隔时间少于设定时间且大于0就重新设置定时器
 if (last < wait && last >= 0) {
 timeout = setTimeout(later, wait - last);
 } else {
 // 否则的话就是时间到了执行回调函数
 timeout = null;
 if (!immediate) {
 result = func.apply(context, args);
 if (!timeout) context = args = null;
 }
 }
 };
 return function() {
 context = this;
 args = arguments;
 // 获得时间戳
 timestamp = _.now();
 // 如果定时器不存在且立即执行函数
 var callNow = immediate && !timeout;
 // 如果定时器不存在就创建一个
 if (!timeout) timeout = setTimeout(later, wait);
 if (callNow) {
 // 如果需要立即执行函数的话 通过 apply 执行
 result = func.apply(context, args);
 context = args = null;
 }
 return result;
 };
 };
```
整体函数实现的不难，总结一下。
? 对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，不
管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再
次点击了。
? 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前
的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时
器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回
调函数。



###函数节流
防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将
多次执行变成每隔一段时间执行。
```
/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗口的间隔
 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。
 * 如果想忽略结尾函数的调用，传入{trailing: false}
 * 两者不能共存，否则函数不能执行
 * @return {function} 返回客户调用函数
 */
_.throttle = function(func, wait, options) {
 var context, args, result;
 var timeout = null;
 // 之前的时间戳
 var previous = 0;
 // 如果 options 没传则设为空对象
 if (!options) options = {};
 // 定时器回调函数
 var later = function() {
 // 如果设置了 leading，就将 previous 设为 0
 // 用于下面函数的第一个 if 判断
 previous = options.leading === false ? 0 : _.now();
 // 置空一是为了防止内存泄漏，二是为了下面的定时器判断
 timeout = null;
 result = func.apply(context, args);
 if (!timeout) context = args = null;
 };
 return function() {
 // 获得当前时间戳
 var now = _.now();
 // 首次进入前者肯定为 true
 // 如果需要第一次不执行函数
 // 就将上次时间戳设为当前的
 // 这样在接下来计算 remaining 的值时会大于0
 if (!previous && options.leading === false) previous = now;
 // 计算剩余时间
 var remaining = wait - (now - previous);
 context = this;
 args = arguments;
 // 如果当前调用已经大于上次调用时间 + wait
 // 或者用户手动调了时间
 // 如果设置了 trailing，只会进入这个条件
 // 如果没有设置 leading，那么第一次会进入这个条件
 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
 // 其实还是会进入的，因为定时器的延时
 // 并不是准确的时间，很可能你设置了2秒
 // 但是他需要2.2秒才触发，这时候就会进入这个条件
 if (remaining <= 0 || remaining > wait) {
 // 如果存在定时器就清理掉否则会调用二次回调
 if (timeout) {
 clearTimeout(timeout);
 timeout = null;
 }
 previous = now;
 result = func.apply(context, args);
 if (!timeout) context = args = null;
 } else if (!timeout && options.trailing !== false) {
 // 判断是否设置了定时器和 trailing
 // 没有的话就开启一个定时器
 // 并且不能不能同时设置 leading 和 trailing
 timeout = setTimeout(later, remaining);
 }
 return result;
 };
 };
```

###异同
简单来说：
防抖：把触发非常频繁的事件（比如按键）合并成一次执行。
节流：保证每 X 毫秒恒定的执行次数，间断执行。

######相同点：

1.都可以通过使用 setTimeout 实现。
2.目的都是，降低回调执行频率。节省计算资源。

######不同点：


1.函数防抖，在一段连续操作结束后，处理回调，利用 clearTimeout 和 setTimeout 实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。
函数2.防抖关注一定时间连续触发，只在最后执行一次，而函数节流侧重于一段时间内只执行一次。



###用法
######_.throttle 使用示例
```
function log( event ) {
  console.log( $(window).scrollTop(), event.timeStamp );
};

// 控制台记录窗口滚动事件，触发频率比你想象的要快
$(window).scroll( log );

// 控制台记录窗口滚动事件，每250ms最多触发一次
$(window).scroll( _.throttle( log, 250 ) );
```


######_.debounce 使用示例
```
function ajax_lookup( event ) {
  // 对输入的内容$(this).val()执行 Ajax 查询
};

// 字符输入的频率比你预想的要快，Ajax 请求来不及回复。
$('input:text').keyup( ajax_lookup );

// 当用户停顿250毫秒以后才开始查找
$('input:text').keyup( _.debounce( ajax_lookup, 250 ) );
```

###underscore源码
Underscore.js是一个很精干的库，压缩后只有5.2KB。它提供了几十种函数式编程的方法，弥补了标准库的不足，大大方便了JavaScript的编程。防抖和节流也在其中，一起读读源码，探其究竟。基于开发版本（1.7.0）的源码，加上了一些注释以帮助理解。

#####_.throttle方法源码
```
/**
 * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait
 * 
 * @param  {function}   func      传入函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。
 *                                如果想忽略结尾边界上的调用，传入{trailing: false}
 * @return {function}             返回客户调用函数   
 */
_.throttle = function(func, wait, options) {
  var context, args, result;
  var timeout = null;
  // 上次执行时间点
  var previous = 0;
  if (!options) options = {};
  // 延迟执行函数
  var later = function() {
    // 若设定了开始边界不执行选项，上次执行时间始终为0
    previous = options.leading === false ? 0 : _.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function() {
    var now = _.now();
    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。
    if (!previous && options.leading === false) previous = now;
    // 延迟执行时间间隔
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    // 延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口
    // remaining大于时间窗口wait，表示客户端系统时间被调整过
    if (remaining <= 0 || remaining > wait) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    //如果延迟执行不存在，且没有设定结尾边界不执行选项
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};
```
#####_.debounce方法源码
```
/**
 * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        传入函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界
 * @return {function}             返回客户调用函数
 */
_.debounce = function(func, wait, immediate) {
  var timeout, args, context, timestamp, result;

  var later = function() {
    // 据上一次触发时间间隔
    var last = _.now() - timestamp;

    // 上次被包装函数被调用时间间隔last小于设定时间间隔wait
    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function() {
    context = this;
    args = arguments;
    timestamp = _.now();
    var callNow = immediate && !timeout;
    // 如果延时不存在，重新设定延时
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
};
```

#####


###总结
最后，总结一下函数防抖与函数节流的区别。函数防抖，将多次执行的事件合并成一次。函数节流，保持一段时间执行一次。推荐阅读「涂鸦码龙」翻译的这篇 - 实例解析防抖动（Debouncing）和节流阀（Throttling），加深理解。文章丰富的实例，可深刻感受一下两者的区别。
在不是很理解 debounce的API的情况下，直接阅读lodash源码，花了2个晚上看得懂云里雾里。后面，重新阅读API文档，弄明白了 leading 和 trailing的目的。很快就看懂了 debounce的源码。因此，建议阅读源码前，先理解API中各个参数的用处。带着目的看源码会容易一些。

作者：youthcity
链接：https://www.jianshu.com/p/f9f6b637fd6c
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。



