###前言
前天在安卓群里听见有同学讨论狼叔发布的2019前端解读，并打算从native转前端，先是惊讶后是感叹，自从HTML5的诞生，前端就逐渐独立出来，这一路上伴随这flash的淘汰、nodeJs的崛起，三大马车的不断发力，包括Flutter的强劲活力，就在不断推动前端发展，尤其是Flutter，以当下的情况来看（2019年3月），如果有大型公司采用flutter，那么一定是前端团队不断宣传的推进的结果。
现在的前端，已经不仅仅是网页，更多的开始由狭义向广义发展。先后涌现出了具备后端能力的node，具备移动开发能力的RN、Flutter，具备游戏渲染能力的Egret、Laya，以及iOS上的热修复技术JSPatch等等新技术。咋一看，几乎各个端都被JavaScript攻陷，准确地说，前端已经逐渐融入各个开发团队。

###JS的坑
前面纯属扯淡，下面开始正经脸.
我们都知道，一个完整的浏览器组成至少包括：排版引擎（内核）、JavaScript引擎。

- 排版引擎
全称是Layout engine，也称为浏览器内核（web browser engine）、页面渲染引擎（rendering engine）或样版引擎）是一种软件组件，负责获取标记式内容（如HTML、XML及图像文件等等）、整理信息（如CSS及XSL等），并将排版后的内容输出至显示器或打印机。所有网页浏览器、电子邮件客户端以及其它需要根据表示性的标记语言（Presentational markup）来显示内容的应用程序都需要排版引擎。

- JavaScript引擎
之前也有介绍过（文章链接：），JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。常见的有SpiderMonkey，V8等等。

其他JavaScript引擎，Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写，可以看做SpiderMonkey的Java版。 注意：webkit不单单只是一个排版引擎，webkit = 排版引擎 + JavaScript引擎。 > 所以，JavaScript是动态语言，它的运行都是基于JavaScript引擎，引擎大都是由静态语言实现C++、Java、and so on。JavaScript的能力也是由引擎赋予。不管是浏览器环境中是window，亦或是node环境中的process，均是由引擎提供。

在浏览器环境中，DOM、BOM、window对象、setTimeout/setInterval，alert，console等方法均不是JavaScript自身具备的能力，而是浏览器native实现，然后通过JavaScript引擎注入到JS运行的全局上下文中，供JS使用。 鉴别方式，在调试器console中打出来，带有[native code]的都是。

原因：
- JavaScript运行 → 依赖于JavaScript引擎 ← 浏览器集成了JavaScript引擎，同时通过JavaScript引擎注入native代码工JS脚本使用。

- 发散一下思维，只要有JavaScript引擎，就能运行JS脚本，不管有没有浏览器！只是缺少浏览器提供的alert，window等方法。

- 既然浏览器可以往JavaScript引擎中注入代码，赋予JS脚本在网页中特殊的能力，同理我们可以自己集成JavaScript引擎，自己定义自己的方法往JavaScript引擎中注入，赋予JS更多更强的自定义能力。

- 注入的关键是：值类型相互对应，Obj映射class的一个实例，function映射一个句柄或者引用

###JS的坑
JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。
这就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。尽量避免使用JavaScript做精准计算和密集计算。
根据国际标准IEEE 754，JavaScript浮点数的64个二进制位，从最左边开始，是这样组成的。

*第1位：符号位，0表示正数，1表示负数

*第2位到第12位：储存指数部分

*第13位到第64位：储存小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。

内部表现公式：(-1)^符号位 * 1.xx...xx * 2^指数位

精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-(253-1)到253-1，都可以精确表示。 而大部分的后端语言，C++、Java、Python等的long型都是可以支持到64位，因此long型数据从后端语言传给JavaScript会发生低位截断。遇到这种情况一般使用String处理，如需要在JavaScript中做long型计算，需要自行实现计算器。

有了自行往JavaScript引擎中注入的想法，接下来就是分析可行性。 大部分是JavaScript引擎是使用C++编写，如果自己的程序使用的是C++可以很方便的进行注入，如果是OC，可以使用OC和C++混编的形式。 其他语言怎么破？ 要在一门静态语言上与动态语言JavaScript相互调用，最便捷的方式是找到一个这门语言实现的JavaScript引擎（开源），直接进行集成，注入。如果没有，则需要使用多一层桥接，把这门语言的接口暴露给C++，再由C++实现的JavaScript引擎将接口注入供JavaScript使用。

###




###