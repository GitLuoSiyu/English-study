###前言
首先需要明确的是 this 既不指向函数自身，也不指函数的词法作用域。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。

###this
this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就
可以了。
```
function foo() {
console.log(this.a)
}
var a = 2
foo()
var obj = {
a: 2,
foo: foo
}
obj.foo()
// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况
// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向

var c = new foo()
c.a = 3
console.log(c.a)
// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```
以上几种情况明白了，很多代码中的 this 应该就没什么问题了，下面让我们看看
箭头函数中的 this
```
function a() {
 return () => {
 return () => {
 console.log(this)
 }
 }
}
console.log(a()()())
```
箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是
箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，
所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。


###执行上下文
当执行 JS 代码时，会产生三种执行上下文
? 全局执行上下文
? 函数执行上下文
? eval 执行上下文

每个执行上下文中都有三个重要的属性
变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中
访问
作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）

```
this
var a = 10
function foo(i) {
 var b = 20
}
foo()
```
对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。
```
stack = [
 globalContext,
 fooContext
]
```
对于全局上下文来说，VO 大概是这样的
```
globalContext.VO === globe
globalContext.VO = {
 a: undefined,
foo: <Function>,
}
```
对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO）
```
fooContext.VO === foo.AO
fooContext.AO {
 i: undefined,
b: undefined,
 arguments: <>
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调用者
```
对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过
[[Scope]] 属性查找上级变量
```
fooContext.[[Scope]] = [
 globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
 fooContext.VO,
 globalContext.VO
]
```
接下来让我们看一个老生常谈的例子，var

```
b() // call b
console.log(a) // undefined
var a = 'Hello world'
function b() {
console.log('call b')
}
```
想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常
提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。
但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建
的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们
提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为
undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。
在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升
```
b() // call b second
function b() {
console.log('call b fist')
}
function b() {
console.log('call b second')
}
var b = 'Hello world'
```
var 会产生很多错误，所以在 ES6 中引入了 let。let 不能在声明前使用，但是
这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并
不能在声明前使用。
对于非匿名的立即执行函数需要注意以下一点

```
var foo = 1
(function foo() {
 foo = 10
 console.log(foo)
}()) // -> ? foo() { foo = 10 ; console.log(foo) }
```
因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，
然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这又个值
是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也
没有发生更改。
```
specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // remove specialObject from the front of scope chain
```

###this的原理
JavaScript里的this就是被调用对象的引用。形象的说，就是那"."之前的那个对象的引用。 
JavaScript里虽然有函数（类型），也有函数（对象），但在调用的时候总是跟某个对象绑定在一起来调用的。直接调用一个看似没有跟什么对象绑定的函数，实际上是跟"全局"对象绑定在一起了。在浏览器DOM里这个全局对象就是window。 
当使用new运算符来构造新对象时，new之后跟着的那个构造器里的"this"指向的就是由new而构造出来的一个空的新对象。这个对象里暂时什么都还没有（有是有，不过DontEnum看不到罢了），而构造器里的this.xxx形式的赋值就能够创建给那个对象新的属性。
说到底，JavaScript里的“对象”不过就是关联数组罢了。按Concepts of Programming Languages一书里的讲法，JavaScript里的对象与perl里的hash是很像的。现下流行的JSON也正是利用了这个特性而发展出来的。 

```
 function fooConstructor() {  
        this.variable = 1;  
    }  
      
    function makeAnonymousFunction() {  
        return function() {  
            this.gooValue = 2;  
        };  
    }  
      
    fooConstructor();          // invoke a function that looks like a constructor  
    makeAnonymousFunction()(); // invoke an anonymous function  
    document.write(variable + "<br />");  
    document.write(window.gooValue + "<br />");  
      
    var obj = new fooConstructor(); // invoke a constructor with "new"  
    document.write(obj.variable + "<br />");  

// 运行结果
1  
2  
1  

```
虽然我们在第一次调用fooConstructor()时并没有以"object.method()"的形式来调用，它实际上等价于window.fooConstructor()。于是我们把window对象（浏览器DOM里的"全局"对象）隐式传给了所调用的函数，在fooConstructor里this就指向了window，并为window对象创建了variable属性，赋值为1。 

makeAnonymousFunction()()的调用是为了演示这个this的指向与嵌套层次的无关性。makeAnonymousFunction()返回了一个函数对象，不过我们没有为这个对象给予一个名字，而是直接调用了它。与前一例一样，这个调用为window对象创建了一个名为gooValue的属性，并赋值为2。 

然后我们演示了以new运算符来创建新对象的状况。这个很普通没什么需要解释的了～


###总结
JavaScript里的this就是被调用对象的引用。形象的说，就是那"."之前的那个对象的引用。